/* automatically generated by rust-bindgen 0.62.0 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const XPLM_NO_PLUGIN_ID: i32 = -1;
pub const XPLM_PLUGIN_XPLANE: u32 = 0;
pub const kXPLM_Version: u32 = 303;
pub const XPLM_KEY_RETURN: u32 = 13;
pub const XPLM_KEY_ESCAPE: u32 = 27;
pub const XPLM_KEY_TAB: u32 = 9;
pub const XPLM_KEY_DELETE: u32 = 8;
pub const XPLM_KEY_LEFT: u32 = 28;
pub const XPLM_KEY_RIGHT: u32 = 29;
pub const XPLM_KEY_UP: u32 = 30;
pub const XPLM_KEY_DOWN: u32 = 31;
pub const XPLM_KEY_0: u32 = 48;
pub const XPLM_KEY_1: u32 = 49;
pub const XPLM_KEY_2: u32 = 50;
pub const XPLM_KEY_3: u32 = 51;
pub const XPLM_KEY_4: u32 = 52;
pub const XPLM_KEY_5: u32 = 53;
pub const XPLM_KEY_6: u32 = 54;
pub const XPLM_KEY_7: u32 = 55;
pub const XPLM_KEY_8: u32 = 56;
pub const XPLM_KEY_9: u32 = 57;
pub const XPLM_KEY_DECIMAL: u32 = 46;
pub const XPLM_VK_BACK: u32 = 8;
pub const XPLM_VK_TAB: u32 = 9;
pub const XPLM_VK_CLEAR: u32 = 12;
pub const XPLM_VK_RETURN: u32 = 13;
pub const XPLM_VK_ESCAPE: u32 = 27;
pub const XPLM_VK_SPACE: u32 = 32;
pub const XPLM_VK_PRIOR: u32 = 33;
pub const XPLM_VK_NEXT: u32 = 34;
pub const XPLM_VK_END: u32 = 35;
pub const XPLM_VK_HOME: u32 = 36;
pub const XPLM_VK_LEFT: u32 = 37;
pub const XPLM_VK_UP: u32 = 38;
pub const XPLM_VK_RIGHT: u32 = 39;
pub const XPLM_VK_DOWN: u32 = 40;
pub const XPLM_VK_SELECT: u32 = 41;
pub const XPLM_VK_PRINT: u32 = 42;
pub const XPLM_VK_EXECUTE: u32 = 43;
pub const XPLM_VK_SNAPSHOT: u32 = 44;
pub const XPLM_VK_INSERT: u32 = 45;
pub const XPLM_VK_DELETE: u32 = 46;
pub const XPLM_VK_HELP: u32 = 47;
pub const XPLM_VK_0: u32 = 48;
pub const XPLM_VK_1: u32 = 49;
pub const XPLM_VK_2: u32 = 50;
pub const XPLM_VK_3: u32 = 51;
pub const XPLM_VK_4: u32 = 52;
pub const XPLM_VK_5: u32 = 53;
pub const XPLM_VK_6: u32 = 54;
pub const XPLM_VK_7: u32 = 55;
pub const XPLM_VK_8: u32 = 56;
pub const XPLM_VK_9: u32 = 57;
pub const XPLM_VK_A: u32 = 65;
pub const XPLM_VK_B: u32 = 66;
pub const XPLM_VK_C: u32 = 67;
pub const XPLM_VK_D: u32 = 68;
pub const XPLM_VK_E: u32 = 69;
pub const XPLM_VK_F: u32 = 70;
pub const XPLM_VK_G: u32 = 71;
pub const XPLM_VK_H: u32 = 72;
pub const XPLM_VK_I: u32 = 73;
pub const XPLM_VK_J: u32 = 74;
pub const XPLM_VK_K: u32 = 75;
pub const XPLM_VK_L: u32 = 76;
pub const XPLM_VK_M: u32 = 77;
pub const XPLM_VK_N: u32 = 78;
pub const XPLM_VK_O: u32 = 79;
pub const XPLM_VK_P: u32 = 80;
pub const XPLM_VK_Q: u32 = 81;
pub const XPLM_VK_R: u32 = 82;
pub const XPLM_VK_S: u32 = 83;
pub const XPLM_VK_T: u32 = 84;
pub const XPLM_VK_U: u32 = 85;
pub const XPLM_VK_V: u32 = 86;
pub const XPLM_VK_W: u32 = 87;
pub const XPLM_VK_X: u32 = 88;
pub const XPLM_VK_Y: u32 = 89;
pub const XPLM_VK_Z: u32 = 90;
pub const XPLM_VK_NUMPAD0: u32 = 96;
pub const XPLM_VK_NUMPAD1: u32 = 97;
pub const XPLM_VK_NUMPAD2: u32 = 98;
pub const XPLM_VK_NUMPAD3: u32 = 99;
pub const XPLM_VK_NUMPAD4: u32 = 100;
pub const XPLM_VK_NUMPAD5: u32 = 101;
pub const XPLM_VK_NUMPAD6: u32 = 102;
pub const XPLM_VK_NUMPAD7: u32 = 103;
pub const XPLM_VK_NUMPAD8: u32 = 104;
pub const XPLM_VK_NUMPAD9: u32 = 105;
pub const XPLM_VK_MULTIPLY: u32 = 106;
pub const XPLM_VK_ADD: u32 = 107;
pub const XPLM_VK_SEPARATOR: u32 = 108;
pub const XPLM_VK_SUBTRACT: u32 = 109;
pub const XPLM_VK_DECIMAL: u32 = 110;
pub const XPLM_VK_DIVIDE: u32 = 111;
pub const XPLM_VK_F1: u32 = 112;
pub const XPLM_VK_F2: u32 = 113;
pub const XPLM_VK_F3: u32 = 114;
pub const XPLM_VK_F4: u32 = 115;
pub const XPLM_VK_F5: u32 = 116;
pub const XPLM_VK_F6: u32 = 117;
pub const XPLM_VK_F7: u32 = 118;
pub const XPLM_VK_F8: u32 = 119;
pub const XPLM_VK_F9: u32 = 120;
pub const XPLM_VK_F10: u32 = 121;
pub const XPLM_VK_F11: u32 = 122;
pub const XPLM_VK_F12: u32 = 123;
pub const XPLM_VK_F13: u32 = 124;
pub const XPLM_VK_F14: u32 = 125;
pub const XPLM_VK_F15: u32 = 126;
pub const XPLM_VK_F16: u32 = 127;
pub const XPLM_VK_F17: u32 = 128;
pub const XPLM_VK_F18: u32 = 129;
pub const XPLM_VK_F19: u32 = 130;
pub const XPLM_VK_F20: u32 = 131;
pub const XPLM_VK_F21: u32 = 132;
pub const XPLM_VK_F22: u32 = 133;
pub const XPLM_VK_F23: u32 = 134;
pub const XPLM_VK_F24: u32 = 135;
pub const XPLM_VK_EQUAL: u32 = 176;
pub const XPLM_VK_MINUS: u32 = 177;
pub const XPLM_VK_RBRACE: u32 = 178;
pub const XPLM_VK_LBRACE: u32 = 179;
pub const XPLM_VK_QUOTE: u32 = 180;
pub const XPLM_VK_SEMICOLON: u32 = 181;
pub const XPLM_VK_BACKSLASH: u32 = 182;
pub const XPLM_VK_COMMA: u32 = 183;
pub const XPLM_VK_SLASH: u32 = 184;
pub const XPLM_VK_PERIOD: u32 = 185;
pub const XPLM_VK_BACKQUOTE: u32 = 186;
pub const XPLM_VK_ENTER: u32 = 187;
pub const XPLM_VK_NUMPAD_ENT: u32 = 188;
pub const XPLM_VK_NUMPAD_EQ: u32 = 189;
pub const XPLM_MAP_USER_INTERFACE: &[u8; 24usize] = b"XPLM_MAP_USER_INTERFACE\0";
pub const XPLM_MAP_IOS: &[u8; 13usize] = b"XPLM_MAP_IOS\0";
pub const XPLM_NAV_NOT_FOUND: i32 = -1;
pub const XPLM_USER_AIRCRAFT: u32 = 0;
pub const XPLM_MSG_PLANE_CRASHED: u32 = 101;
pub const XPLM_MSG_PLANE_LOADED: u32 = 102;
pub const XPLM_MSG_AIRPORT_LOADED: u32 = 103;
pub const XPLM_MSG_SCENERY_LOADED: u32 = 104;
pub const XPLM_MSG_AIRPLANE_COUNT_CHANGED: u32 = 105;
pub const XPLM_MSG_PLANE_UNLOADED: u32 = 106;
pub const XPLM_MSG_WILL_WRITE_PREFS: u32 = 107;
pub const XPLM_MSG_LIVERY_LOADED: u32 = 108;
pub const XPLM_MSG_ENTERED_VR: u32 = 109;
pub const XPLM_MSG_EXITING_VR: u32 = 110;
pub const XPLM_MSG_RELEASE_PLANES: u32 = 111;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " XPLMPluginID"]
#[doc = ""]
#[doc = " Each plug-in is identified by a unique integer ID.  This ID can be used to"]
#[doc = " disable or enable a plug-in, or discover what plug-in is 'running' at the"]
#[doc = " time.  A plug-in ID is unique within the currently running instance of"]
#[doc = " X-Plane unless plug-ins are reloaded.  Plug-ins may receive a different"]
#[doc = " unique ID each time they are loaded. This includes the unloading and"]
#[doc = " reloading of plugins that are part of the user's aircraft."]
#[doc = ""]
#[doc = " For persistent identification of plug-ins, use XPLMFindPluginBySignature in"]
#[doc = " XPLMUtiltiies.h"]
#[doc = ""]
#[doc = " -1 indicates no plug-in."]
#[doc = ""]
pub type XPLMPluginID = ::std::os::raw::c_int;
#[doc = " The shift key is down"]
pub const xplm_ShiftFlag: _bindgen_ty_1 = 1;
#[doc = " The option or alt key is down"]
pub const xplm_OptionAltFlag: _bindgen_ty_1 = 2;
#[doc = " The control key is down*"]
pub const xplm_ControlFlag: _bindgen_ty_1 = 4;
#[doc = " The key is being pressed down"]
pub const xplm_DownFlag: _bindgen_ty_1 = 8;
#[doc = " The key is being released"]
pub const xplm_UpFlag: _bindgen_ty_1 = 16;
#[doc = " XPLMKeyFlags"]
#[doc = ""]
#[doc = " These bitfields define modifier keys in a platform independent way. When a"]
#[doc = " key is pressed, a series of messages are sent to your plugin.  The down"]
#[doc = " flag is set in the first of these messages, and the up flag in the last."]
#[doc = " While the key is held down, messages are sent with neither to indicate that"]
#[doc = " the key is being held down as a repeated character."]
#[doc = ""]
#[doc = " The control flag is mapped to the control flag on Macintosh and PC."]
#[doc = " Generally X-Plane uses the control key and not the command key on"]
#[doc = " Macintosh, providing a consistent interface across platforms that does not"]
#[doc = " necessarily match the Macintosh user interface guidelines.  There is not"]
#[doc = " yet a way for plugins to access the Macintosh control keys without using"]
#[doc = " #ifdefed code."]
#[doc = ""]
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub type XPLMKeyFlags = ::std::os::raw::c_int;
#[doc = " Control the camera until the user picks a new view."]
pub const xplm_ControlCameraUntilViewChanges: _bindgen_ty_2 = 1;
#[doc = " Control the camera until your plugin is disabled or another plugin forcably*"]
#[doc = " takes control."]
pub const xplm_ControlCameraForever: _bindgen_ty_2 = 2;
#[doc = " XPLMCameraControlDuration"]
#[doc = ""]
#[doc = " This enumeration states how long you want to retain control of the camera."]
#[doc = " You can retain it indefinitely or until the user selects a new view."]
#[doc = ""]
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub type XPLMCameraControlDuration = ::std::os::raw::c_int;
#[doc = " XPLMCameraPosition_t"]
#[doc = ""]
#[doc = " This structure contains a full specification of the camera. X, Y, and Z are"]
#[doc = " the camera's position in OpenGL coordiantes; pitch, roll, and yaw are"]
#[doc = " rotations from a camera facing flat north in degrees. Positive pitch means"]
#[doc = " nose up, positive roll means roll right, and positive yaw means yaw right,"]
#[doc = " all in degrees. Zoom is a zoom factor, with 1.0 meaning normal zoom and 2.0"]
#[doc = " magnifying by 2x (objects appear larger)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPLMCameraPosition_t {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub pitch: f32,
    pub heading: f32,
    pub roll: f32,
    pub zoom: f32,
}
#[test]
fn bindgen_test_layout_XPLMCameraPosition_t() {
    const UNINIT: ::std::mem::MaybeUninit<XPLMCameraPosition_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XPLMCameraPosition_t>(),
        28usize,
        concat!("Size of: ", stringify!(XPLMCameraPosition_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XPLMCameraPosition_t>(),
        4usize,
        concat!("Alignment of ", stringify!(XPLMCameraPosition_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heading) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(roll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zoom) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCameraPosition_t),
            "::",
            stringify!(zoom)
        )
    );
}
#[doc = " XPLMCameraControl_f"]
#[doc = ""]
#[doc = " You use an XPLMCameraControl function to provide continuous control over"]
#[doc = " the camera. You are passed in a structure in which to put the new camera"]
#[doc = " position; modify it and return 1 to reposition the camera. Return 0 to"]
#[doc = " surrender control of the camera; camera control will be handled by X-Plane"]
#[doc = " on this draw loop. The contents of the structure as you are called are"]
#[doc = " undefined."]
#[doc = ""]
#[doc = " If X-Plane is taking camera control away from you, this function will be"]
#[doc = " called with inIsLosingControl set to 1 and ioCameraPosition NULL."]
#[doc = ""]
pub type XPLMCameraControl_f = ::std::option::Option<
    unsafe extern "C" fn(
        outCameraPosition: *mut XPLMCameraPosition_t,
        inIsLosingControl: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " XPLMControlCamera"]
    #[doc = ""]
    #[doc = " This function repositions the camera on the next drawing cycle. You must"]
    #[doc = " pass a non-null control function. Specify in inHowLong how long you'd like"]
    #[doc = " control (indefinitely or until a new view mode is set by the user)."]
    #[doc = ""]
    pub fn XPLMControlCamera(
        inHowLong: XPLMCameraControlDuration,
        inControlFunc: XPLMCameraControl_f,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMDontControlCamera"]
    #[doc = ""]
    #[doc = " This function stops you from controlling the camera. If you have a camera"]
    #[doc = " control function, it will not be called with an inIsLosingControl flag."]
    #[doc = " X-Plane will control the camera on the next cycle."]
    #[doc = ""]
    #[doc = " For maximum compatibility you should not use this routine unless you are in"]
    #[doc = " posession of the camera."]
    #[doc = ""]
    pub fn XPLMDontControlCamera();
}
extern "C" {
    #[doc = " XPLMIsCameraBeingControlled"]
    #[doc = ""]
    #[doc = " This routine returns 1 if the camera is being controlled, zero if it is"]
    #[doc = " not. If it is and you pass in a pointer to a camera control duration, the"]
    #[doc = " current control duration will be returned."]
    #[doc = ""]
    pub fn XPLMIsCameraBeingControlled(
        outCameraControlDuration: *mut XPLMCameraControlDuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMReadCameraPosition"]
    #[doc = ""]
    #[doc = " This function reads the current camera position."]
    #[doc = ""]
    pub fn XPLMReadCameraPosition(outCameraPosition: *mut XPLMCameraPosition_t);
}
#[doc = " XPLMDataRef"]
#[doc = ""]
#[doc = " A data ref is an opaque handle to data provided by the simulator or another"]
#[doc = " plugin. It uniquely identifies one variable (or array of variables) over"]
#[doc = " the lifetime of your plugin. You never hard code these values; you always"]
#[doc = " get them from XPLMFindDataRef."]
#[doc = ""]
pub type XPLMDataRef = *mut ::std::os::raw::c_void;
#[doc = " Data of a type the current XPLM doesn't do."]
pub const xplmType_Unknown: _bindgen_ty_3 = 0;
#[doc = " A single 4-byte integer, native endian."]
pub const xplmType_Int: _bindgen_ty_3 = 1;
#[doc = " A single 4-byte float, native endian."]
pub const xplmType_Float: _bindgen_ty_3 = 2;
#[doc = " A single 8-byte double, native endian."]
pub const xplmType_Double: _bindgen_ty_3 = 4;
#[doc = " An array of 4-byte floats, native endian."]
pub const xplmType_FloatArray: _bindgen_ty_3 = 8;
#[doc = " An array of 4-byte integers, native endian."]
pub const xplmType_IntArray: _bindgen_ty_3 = 16;
#[doc = " A variable block of data."]
pub const xplmType_Data: _bindgen_ty_3 = 32;
#[doc = " XPLMDataTypeID"]
#[doc = ""]
#[doc = " This is an enumeration that defines the type of the data behind a data"]
#[doc = " reference. This allows you to sanity check that the data type matches what"]
#[doc = " you expect. But for the most part, you will know the type of data you are"]
#[doc = " expecting from the online documentation."]
#[doc = ""]
#[doc = " Data types each take a bit field; it is legal to have a single dataref be"]
#[doc = " more than one type of data.  Whe this happens, you can pick any matching"]
#[doc = " get/set API."]
#[doc = ""]
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
pub type XPLMDataTypeID = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMFindDataRef"]
    #[doc = ""]
    #[doc = " Given a c-style string that names the data ref, this routine looks up the"]
    #[doc = " actual opaque XPLMDataRef that you use to read and write the data. The"]
    #[doc = " string names for datarefs are published on the X-Plane SDK web site."]
    #[doc = ""]
    #[doc = " This function returns NULL if the data ref cannot be found."]
    #[doc = ""]
    #[doc = " NOTE: this function is relatively expensive; save the XPLMDataRef this"]
    #[doc = " function returns for future use. Do not look up your data ref by string"]
    #[doc = " every time you need to read or write it."]
    #[doc = ""]
    pub fn XPLMFindDataRef(inDataRefName: *const ::std::os::raw::c_char) -> XPLMDataRef;
}
extern "C" {
    #[doc = " XPLMCanWriteDataRef"]
    #[doc = ""]
    #[doc = " Given a data ref, this routine returns true if you can successfully set the"]
    #[doc = " data, false otherwise. Some datarefs are read-only."]
    #[doc = ""]
    #[doc = " NOTE: even if a dataref is marked writable, it may not act writable.  This"]
    #[doc = " can happen for datarefs that X-Plane writes to on every frame of"]
    #[doc = " simulation.  In some cases, the dataref is writable but you have to set a"]
    #[doc = " separate \"override\" dataref to 1 to stop X-Plane from writing it."]
    #[doc = ""]
    pub fn XPLMCanWriteDataRef(inDataRef: XPLMDataRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMIsDataRefGood"]
    #[doc = ""]
    #[doc = " This function returns true if the passed in handle is a valid dataref that"]
    #[doc = " is not orphaned."]
    #[doc = ""]
    #[doc = " Note: there is normally no need to call this function; datarefs returned by"]
    #[doc = " XPLMFindDataRef remain valid (but possibly orphaned) unless there is a"]
    #[doc = " complete plugin reload (in which case your plugin is reloaded anyway)."]
    #[doc = " Orphaned datarefs can be safely read and return 0. Therefore you never need"]
    #[doc = " to call XPLMIsDataRefGood to 'check' the safety of a dataref."]
    #[doc = " (XPLMIsDatarefGood performs some slow checking of the handle validity, so"]
    #[doc = " it has a perormance cost.)"]
    #[doc = ""]
    pub fn XPLMIsDataRefGood(inDataRef: XPLMDataRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMGetDataRefTypes"]
    #[doc = ""]
    #[doc = " This routine returns the types of the data ref for accessor use. If a data"]
    #[doc = " ref is available in multiple data types, the bit-wise OR of these types"]
    #[doc = " will be returned."]
    #[doc = ""]
    pub fn XPLMGetDataRefTypes(inDataRef: XPLMDataRef) -> XPLMDataTypeID;
}
extern "C" {
    #[doc = " XPLMGetDatai"]
    #[doc = ""]
    #[doc = " Read an integer data ref and return its value. The return value is the"]
    #[doc = " dataref value or 0 if the dataref is NULL or the plugin is disabled."]
    #[doc = ""]
    pub fn XPLMGetDatai(inDataRef: XPLMDataRef) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetDatai"]
    #[doc = ""]
    #[doc = " Write a new value to an integer data ref. This routine is a no-op if the"]
    #[doc = " plugin publishing the dataref is disabled, the dataref is NULL, or the"]
    #[doc = " dataref is not writable."]
    #[doc = ""]
    pub fn XPLMSetDatai(inDataRef: XPLMDataRef, inValue: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMGetDataf"]
    #[doc = ""]
    #[doc = " Read a single precision floating point dataref and return its value. The"]
    #[doc = " return value is the dataref value or 0.0 if the dataref is NULL or the"]
    #[doc = " plugin is disabled."]
    #[doc = ""]
    pub fn XPLMGetDataf(inDataRef: XPLMDataRef) -> f32;
}
extern "C" {
    #[doc = " XPLMSetDataf"]
    #[doc = ""]
    #[doc = " Write a new value to a single precision floating point data ref. This"]
    #[doc = " routine is a no-op if the plugin publishing the dataref is disabled, the"]
    #[doc = " dataref is NULL, or the dataref is not writable."]
    #[doc = ""]
    pub fn XPLMSetDataf(inDataRef: XPLMDataRef, inValue: f32);
}
extern "C" {
    #[doc = " XPLMGetDatad"]
    #[doc = ""]
    #[doc = " Read a double precision floating point dataref and return its value. The"]
    #[doc = " return value is the dataref value or 0.0 if the dataref is NULL or the"]
    #[doc = " plugin is disabled."]
    #[doc = ""]
    pub fn XPLMGetDatad(inDataRef: XPLMDataRef) -> f64;
}
extern "C" {
    #[doc = " XPLMSetDatad"]
    #[doc = ""]
    #[doc = " Write a new value to a double precision floating point data ref. This"]
    #[doc = " routine is a no-op if the plugin publishing the dataref is disabled, the"]
    #[doc = " dataref is NULL, or the dataref is not writable."]
    #[doc = ""]
    pub fn XPLMSetDatad(inDataRef: XPLMDataRef, inValue: f64);
}
extern "C" {
    #[doc = " XPLMGetDatavi"]
    #[doc = ""]
    #[doc = " Read a part of an integer array dataref. If you pass NULL for outValues,"]
    #[doc = " the routine will return the size of the array, ignoring inOffset and inMax."]
    #[doc = ""]
    #[doc = " If outValues is not NULL, then up to inMax values are copied from the"]
    #[doc = " dataref into outValues, starting at inOffset in the dataref. If inMax +"]
    #[doc = " inOffset is larger than the size of the dataref, less than inMax values"]
    #[doc = " will be copied. The number of values copied is returned."]
    #[doc = ""]
    #[doc = " Note: the semantics of array datarefs are entirely implemented by the"]
    #[doc = " plugin (or X-Plane) that provides the dataref, not the SDK itself; the"]
    #[doc = " above description is how these datarefs are intended to work, but a rogue"]
    #[doc = " plugin may have different behavior."]
    #[doc = ""]
    pub fn XPLMGetDatavi(
        inDataRef: XPLMDataRef,
        outValues: *mut ::std::os::raw::c_int,
        inOffset: ::std::os::raw::c_int,
        inMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetDatavi"]
    #[doc = ""]
    #[doc = " Write part or all of an integer array dataref. The values passed by"]
    #[doc = " inValues are written into the dataref starting at inOffset. Up to inCount"]
    #[doc = " values are written; however if the values would write \"off the end\" of the"]
    #[doc = " dataref array, then fewer values are written."]
    #[doc = ""]
    #[doc = " Note: the semantics of array datarefs are entirely implemented by the"]
    #[doc = " plugin (or X-Plane) that provides the dataref, not the SDK itself; the"]
    #[doc = " above description is how these datarefs are intended to work, but a rogue"]
    #[doc = " plugin may have different behavior."]
    #[doc = ""]
    pub fn XPLMSetDatavi(
        inDataRef: XPLMDataRef,
        inValues: *mut ::std::os::raw::c_int,
        inoffset: ::std::os::raw::c_int,
        inCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetDatavf"]
    #[doc = ""]
    #[doc = " Read a part of a single precision floating point array dataref. If you pass"]
    #[doc = " NULL for outVaules, the routine will return the size of the array, ignoring"]
    #[doc = " inOffset and inMax."]
    #[doc = ""]
    #[doc = " If outValues is not NULL, then up to inMax values are copied from the"]
    #[doc = " dataref into outValues, starting at inOffset in the dataref. If inMax +"]
    #[doc = " inOffset is larger than the size of the dataref, less than inMax values"]
    #[doc = " will be copied. The number of values copied is returned."]
    #[doc = ""]
    #[doc = " Note: the semantics of array datarefs are entirely implemented by the"]
    #[doc = " plugin (or X-Plane) that provides the dataref, not the SDK itself; the"]
    #[doc = " above description is how these datarefs are intended to work, but a rogue"]
    #[doc = " plugin may have different behavior."]
    #[doc = ""]
    pub fn XPLMGetDatavf(
        inDataRef: XPLMDataRef,
        outValues: *mut f32,
        inOffset: ::std::os::raw::c_int,
        inMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetDatavf"]
    #[doc = ""]
    #[doc = " Write part or all of a single precision floating point array dataref. The"]
    #[doc = " values passed by inValues are written into the dataref starting at"]
    #[doc = " inOffset. Up to inCount values are written; however if the values would"]
    #[doc = " write \"off the end\" of the dataref array, then fewer values are written."]
    #[doc = ""]
    #[doc = " Note: the semantics of array datarefs are entirely implemented by the"]
    #[doc = " plugin (or X-Plane) that provides the dataref, not the SDK itself; the"]
    #[doc = " above description is how these datarefs are intended to work, but a rogue"]
    #[doc = " plugin may have different behavior."]
    #[doc = ""]
    pub fn XPLMSetDatavf(
        inDataRef: XPLMDataRef,
        inValues: *mut f32,
        inoffset: ::std::os::raw::c_int,
        inCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetDatab"]
    #[doc = ""]
    #[doc = " Read a part of a byte array dataref. If you pass NULL for outVaules, the"]
    #[doc = " routine will return the size of the array, ignoring inOffset and inMax."]
    #[doc = ""]
    #[doc = " If outValues is not NULL, then up to inMax values are copied from the"]
    #[doc = " dataref into outValues, starting at inOffset in the dataref. If inMax +"]
    #[doc = " inOffset is larger than the size of the dataref, less than inMax values"]
    #[doc = " will be copied. The number of values copied is returned."]
    #[doc = ""]
    #[doc = " Note: the semantics of array datarefs are entirely implemented by the"]
    #[doc = " plugin (or X-Plane) that provides the dataref, not the SDK itself; the"]
    #[doc = " above description is how these datarefs are intended to work, but a rogue"]
    #[doc = " plugin may have different behavior."]
    #[doc = ""]
    pub fn XPLMGetDatab(
        inDataRef: XPLMDataRef,
        outValue: *mut ::std::os::raw::c_void,
        inOffset: ::std::os::raw::c_int,
        inMaxBytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetDatab"]
    #[doc = ""]
    #[doc = " Write part or all of a byte array dataref. The values passed by inValues"]
    #[doc = " are written into the dataref starting at inOffset. Up to inCount values are"]
    #[doc = " written; however if the values would write \"off the end\" of the dataref"]
    #[doc = " array, then fewer values are written."]
    #[doc = ""]
    #[doc = " Note: the semantics of array datarefs are entirely implemented by the"]
    #[doc = " plugin (or X-Plane) that provides the dataref, not the SDK itself; the"]
    #[doc = " above description is how these datarefs are intended to work, but a rogue"]
    #[doc = " plugin may have different behavior."]
    #[doc = ""]
    pub fn XPLMSetDatab(
        inDataRef: XPLMDataRef,
        inValue: *mut ::std::os::raw::c_void,
        inOffset: ::std::os::raw::c_int,
        inLength: ::std::os::raw::c_int,
    );
}
#[doc = " XPLMGetDatai_f"]
#[doc = ""]
#[doc = " Data provider function pointers."]
#[doc = ""]
#[doc = " These define the function pointers you provide to get or set data. Note"]
#[doc = " that you are passed a generic pointer for each one. This is the same"]
#[doc = " pointer you pass in your register routine; you can use it to locate plugin"]
#[doc = " variables, etc."]
#[doc = ""]
#[doc = " The semantics of your callbacks are the same as the dataref accessor above"]
#[doc = " - basically routines like XPLMGetDatai are just pass-throughs from a caller"]
#[doc = " to your plugin. Be particularly mindful in implementing array dataref"]
#[doc = " read-write accessors; you are responsible for avoiding overruns, supporting"]
#[doc = " offset read/writes, and handling a read with a NULL buffer."]
#[doc = ""]
pub type XPLMGetDatai_f = ::std::option::Option<
    unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " XPLMSetDatai_f"]
#[doc = ""]
pub type XPLMSetDatai_f = ::std::option::Option<
    unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void, inValue: ::std::os::raw::c_int),
>;
#[doc = " XPLMGetDataf_f"]
#[doc = ""]
pub type XPLMGetDataf_f =
    ::std::option::Option<unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void) -> f32>;
#[doc = " XPLMSetDataf_f"]
#[doc = ""]
pub type XPLMSetDataf_f = ::std::option::Option<
    unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void, inValue: f32),
>;
#[doc = " XPLMGetDatad_f"]
#[doc = ""]
pub type XPLMGetDatad_f =
    ::std::option::Option<unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void) -> f64>;
#[doc = " XPLMSetDatad_f"]
#[doc = ""]
pub type XPLMSetDatad_f = ::std::option::Option<
    unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void, inValue: f64),
>;
#[doc = " XPLMGetDatavi_f"]
#[doc = ""]
pub type XPLMGetDatavi_f = ::std::option::Option<
    unsafe extern "C" fn(
        inRefcon: *mut ::std::os::raw::c_void,
        outValues: *mut ::std::os::raw::c_int,
        inOffset: ::std::os::raw::c_int,
        inMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " XPLMSetDatavi_f"]
#[doc = ""]
pub type XPLMSetDatavi_f = ::std::option::Option<
    unsafe extern "C" fn(
        inRefcon: *mut ::std::os::raw::c_void,
        inValues: *mut ::std::os::raw::c_int,
        inOffset: ::std::os::raw::c_int,
        inCount: ::std::os::raw::c_int,
    ),
>;
#[doc = " XPLMGetDatavf_f"]
#[doc = ""]
pub type XPLMGetDatavf_f = ::std::option::Option<
    unsafe extern "C" fn(
        inRefcon: *mut ::std::os::raw::c_void,
        outValues: *mut f32,
        inOffset: ::std::os::raw::c_int,
        inMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " XPLMSetDatavf_f"]
#[doc = ""]
pub type XPLMSetDatavf_f = ::std::option::Option<
    unsafe extern "C" fn(
        inRefcon: *mut ::std::os::raw::c_void,
        inValues: *mut f32,
        inOffset: ::std::os::raw::c_int,
        inCount: ::std::os::raw::c_int,
    ),
>;
#[doc = " XPLMGetDatab_f"]
#[doc = ""]
pub type XPLMGetDatab_f = ::std::option::Option<
    unsafe extern "C" fn(
        inRefcon: *mut ::std::os::raw::c_void,
        outValue: *mut ::std::os::raw::c_void,
        inOffset: ::std::os::raw::c_int,
        inMaxLength: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " XPLMSetDatab_f"]
#[doc = ""]
pub type XPLMSetDatab_f = ::std::option::Option<
    unsafe extern "C" fn(
        inRefcon: *mut ::std::os::raw::c_void,
        inValue: *mut ::std::os::raw::c_void,
        inOffset: ::std::os::raw::c_int,
        inLength: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    #[doc = " XPLMRegisterDataAccessor"]
    #[doc = ""]
    #[doc = " This routine creates a new item of data that can be read and written. Pass"]
    #[doc = " in the data's full name for searching, the type(s) of the data for"]
    #[doc = " accessing, and whether the data can be written to. For each data type you"]
    #[doc = " support, pass in a read accessor function and a write accessor function if"]
    #[doc = " necessary. Pass NULL for data types you do not support or write accessors"]
    #[doc = " if you are read-only."]
    #[doc = ""]
    #[doc = " You are returned a data ref for the new item of data created. You can use"]
    #[doc = " this data ref to unregister your data later or read or write from it."]
    #[doc = ""]
    pub fn XPLMRegisterDataAccessor(
        inDataName: *const ::std::os::raw::c_char,
        inDataType: XPLMDataTypeID,
        inIsWritable: ::std::os::raw::c_int,
        inReadInt: XPLMGetDatai_f,
        inWriteInt: XPLMSetDatai_f,
        inReadFloat: XPLMGetDataf_f,
        inWriteFloat: XPLMSetDataf_f,
        inReadDouble: XPLMGetDatad_f,
        inWriteDouble: XPLMSetDatad_f,
        inReadIntArray: XPLMGetDatavi_f,
        inWriteIntArray: XPLMSetDatavi_f,
        inReadFloatArray: XPLMGetDatavf_f,
        inWriteFloatArray: XPLMSetDatavf_f,
        inReadData: XPLMGetDatab_f,
        inWriteData: XPLMSetDatab_f,
        inReadRefcon: *mut ::std::os::raw::c_void,
        inWriteRefcon: *mut ::std::os::raw::c_void,
    ) -> XPLMDataRef;
}
extern "C" {
    #[doc = " XPLMUnregisterDataAccessor"]
    #[doc = ""]
    #[doc = " Use this routine to unregister any data accessors you may have registered."]
    #[doc = " You unregister a data ref by the XPLMDataRef you get back from"]
    #[doc = " registration. Once you unregister a data ref, your function pointer will"]
    #[doc = " not be called anymore."]
    #[doc = ""]
    pub fn XPLMUnregisterDataAccessor(inDataRef: XPLMDataRef);
}
#[doc = " XPLMDataChanged_f"]
#[doc = ""]
#[doc = " An XPLMDataChanged_f is a callback that the XPLM calls whenever any other"]
#[doc = " plug-in modifies shared data. A refcon you provide is passed back to help"]
#[doc = " identify which data is being changed. In response, you may want to call one"]
#[doc = " of the XPLMGetDataxxx routines to find the new value of the data."]
#[doc = ""]
pub type XPLMDataChanged_f =
    ::std::option::Option<unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " XPLMShareData"]
    #[doc = ""]
    #[doc = " This routine connects a plug-in to shared data, creating the shared data if"]
    #[doc = " necessary. inDataName is a standard path for the data ref, and inDataType"]
    #[doc = " specifies the type. This function will create the data if it does not"]
    #[doc = " exist. If the data already exists but the type does not match, an error is"]
    #[doc = " returned, so it is important that plug-in authors collaborate to establish"]
    #[doc = " public standards for shared data."]
    #[doc = ""]
    #[doc = " If a notificationFunc is passed in and is not NULL, that notification"]
    #[doc = " function will be called whenever the data is modified. The notification"]
    #[doc = " refcon will be passed to it. This allows your plug-in to know which shared"]
    #[doc = " data was changed if multiple shared data are handled by one callback, or if"]
    #[doc = " the plug-in does not use global variables."]
    #[doc = ""]
    #[doc = " A one is returned for successfully creating or finding the shared data; a"]
    #[doc = " zero if the data already exists but is of the wrong type."]
    #[doc = ""]
    pub fn XPLMShareData(
        inDataName: *const ::std::os::raw::c_char,
        inDataType: XPLMDataTypeID,
        inNotificationFunc: XPLMDataChanged_f,
        inNotificationRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMUnshareData"]
    #[doc = ""]
    #[doc = " This routine removes your notification function for shared data. Call it"]
    #[doc = " when done with the data to stop receiving change notifications. Arguments"]
    #[doc = " must match XPLMShareData. The actual memory will not necessarily be freed,"]
    #[doc = " since other plug-ins could be using it."]
    #[doc = ""]
    pub fn XPLMUnshareData(
        inDataName: *const ::std::os::raw::c_char,
        inDataType: XPLMDataTypeID,
        inNotificationFunc: XPLMDataChanged_f,
        inNotificationRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This is the first phase where you can draw in 2-d."]
pub const xplm_Phase_FirstCockpit: _bindgen_ty_4 = 35;
#[doc = " The non-moving parts of the aircraft panel."]
pub const xplm_Phase_Panel: _bindgen_ty_4 = 40;
#[doc = " The moving parts of the aircraft panel."]
pub const xplm_Phase_Gauges: _bindgen_ty_4 = 45;
#[doc = " Floating windows from plugins."]
pub const xplm_Phase_Window: _bindgen_ty_4 = 50;
#[doc = " The last chance to draw in 2d."]
pub const xplm_Phase_LastCockpit: _bindgen_ty_4 = 55;
#[doc = " Removed as of XPLM300; Use the full-blown XPLMMap API instead."]
pub const xplm_Phase_LocalMap3D: _bindgen_ty_4 = 100;
#[doc = " Removed as of XPLM300; Use the full-blown XPLMMap API instead."]
pub const xplm_Phase_LocalMap2D: _bindgen_ty_4 = 101;
#[doc = " Removed as of XPLM300; Use the full-blown XPLMMap API instead."]
pub const xplm_Phase_LocalMapProfile: _bindgen_ty_4 = 102;
#[doc = " XPLMDrawingPhase"]
#[doc = ""]
#[doc = " This constant indicates which part of drawing we are in.  Drawing is done"]
#[doc = " from the back to the front.  We get a callback before or after each item."]
#[doc = " Metaphases provide access to the beginning and end of the 3d (scene) and"]
#[doc = " 2d (cockpit) drawing in a manner that is independent of new phases added"]
#[doc = "  via X-Plane implementation."]
#[doc = ""]
#[doc = " **NOTE**: As of XPLM302 the legacy 3D drawing phases (xplm_Phase_FirstScene"]
#[doc = "   to xplm_Phase_LastScene) are deprecated. When running under X-Plane 11.50"]
#[doc = "   with the modern Vulkan or Metal backend, X-Plane will no longer call"]
#[doc = "   these drawing phases. There is a new drawing phase, xplm_Phase_Modern3D,"]
#[doc = "   which is supported under OpenGL and Vulkan which is called out roughly"]
#[doc = "   where the old before xplm_Phase_Airplanes phase was for blending. This"]
#[doc = "   phase is *NOT* supported under Metal and comes with potentially"]
#[doc = "   substantial performance overhead. Please do *NOT* opt into this phase if"]
#[doc = "   you don't do any actual drawing that requires the depth buffer in some"]
#[doc = "   way!"]
#[doc = ""]
#[doc = " **WARNING**: As X-Plane's scenery evolves, some drawing phases may cease to"]
#[doc = "   exist and new ones may be invented.  If you need a particularly specific"]
#[doc = "   use of these codes, consult Austin and/or be prepared to revise your code"]
#[doc = "   as X-Plane evolves."]
#[doc = ""]
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
pub type XPLMDrawingPhase = ::std::os::raw::c_int;
#[doc = " XPLMDrawCallback_f"]
#[doc = ""]
#[doc = " This is the prototype for a low level drawing callback.  You are passed in"]
#[doc = " the phase and whether it is before or after.  If you are before the phase,"]
#[doc = " return 1 to let X-Plane draw or 0 to suppress X-Plane drawing.  If you are"]
#[doc = " after the phase the return value is ignored."]
#[doc = ""]
#[doc = " Refcon is a unique value that you specify when registering the callback,"]
#[doc = " allowing you to slip a pointer to your own data to the callback."]
#[doc = ""]
#[doc = " Upon entry the OpenGL context will be correctly set up for you and OpenGL"]
#[doc = " will be in 'local' coordinates for 3d drawing and panel coordinates for 2d"]
#[doc = " drawing.  The OpenGL state (texturing, etc.) will be unknown."]
#[doc = ""]
pub type XPLMDrawCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        inPhase: XPLMDrawingPhase,
        inIsBefore: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " XPLMRegisterDrawCallback"]
    #[doc = ""]
    #[doc = " This routine registers a low level drawing callback.  Pass in the phase you"]
    #[doc = " want to be called for and whether you want to be called before or after."]
    #[doc = " This routine returns 1 if the registration was successful, or 0 if the"]
    #[doc = " phase does not exist in this version of X-Plane.  You may register a"]
    #[doc = " callback multiple times for the same or different phases as long as the"]
    #[doc = " refcon is unique each time."]
    #[doc = ""]
    #[doc = " Note that this function will likely be removed during the X-Plane 11 run as"]
    #[doc = " part of the transition to Vulkan/Metal/etc. See the XPLMInstance API for"]
    #[doc = " future-proof drawing of 3-D objects."]
    #[doc = ""]
    pub fn XPLMRegisterDrawCallback(
        inCallback: XPLMDrawCallback_f,
        inPhase: XPLMDrawingPhase,
        inWantsBefore: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMUnregisterDrawCallback"]
    #[doc = ""]
    #[doc = " This routine unregisters a draw callback.  You must unregister a callback"]
    #[doc = " for each time you register a callback if you have registered it multiple"]
    #[doc = " times with different refcons.  The routine returns 1 if it can find the"]
    #[doc = " callback to unregister, 0 otherwise."]
    #[doc = ""]
    #[doc = " Note that this function will likely be removed during the X-Plane 11 run as"]
    #[doc = " part of the transition to Vulkan/Metal/etc. See the XPLMInstance API for"]
    #[doc = " future-proof drawing of 3-D objects."]
    #[doc = ""]
    pub fn XPLMUnregisterDrawCallback(
        inCallback: XPLMDrawCallback_f,
        inPhase: XPLMDrawingPhase,
        inWantsBefore: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " XPLMWindowID"]
#[doc = ""]
#[doc = " This is an opaque identifier for a window.  You use it to control your"]
#[doc = " window. When you create a window (via either XPLMCreateWindow() or"]
#[doc = " XPLMCreateWindowEx()), you will specify callbacks to handle drawing, mouse"]
#[doc = " interaction, etc."]
#[doc = ""]
pub type XPLMWindowID = *mut ::std::os::raw::c_void;
#[doc = " XPLMDrawWindow_f"]
#[doc = ""]
#[doc = " A callback to handle 2-D drawing of your window.  You are passed in your"]
#[doc = " window and its refcon. Draw the window.  You can use other XPLM functions"]
#[doc = " from this header to find the current dimensions of your window, etc.  When"]
#[doc = " this callback is called, the OpenGL context will be set properly for 2-D"]
#[doc = " window drawing."]
#[doc = ""]
#[doc = " **Note**: Because you are drawing your window over a background, you can"]
#[doc = "   make a translucent window easily by simply not filling in your entire"]
#[doc = "   window's bounds."]
#[doc = ""]
pub type XPLMDrawWindow_f = ::std::option::Option<
    unsafe extern "C" fn(inWindowID: XPLMWindowID, inRefcon: *mut ::std::os::raw::c_void),
>;
#[doc = " XPLMHandleKey_f"]
#[doc = ""]
#[doc = " This function is called when a key is pressed or keyboard focus is taken"]
#[doc = " away from your window.  If losingFocus is 1, you are losing the keyboard"]
#[doc = " focus, otherwise a key was pressed and inKey contains its character.  You"]
#[doc = " are also passed your window and a refcon."]
#[doc = ""]
#[doc = " Warning: this API declares virtual keys as a signed character; however the"]
#[doc = " VKEY #define macros in XPLMDefs.h define the vkeys using unsigned values"]
#[doc = " (that is 0x80 instead of -0x80).  So you may need to cast the incoming vkey"]
#[doc = " to an unsigned char to get correct comparisons in C."]
#[doc = ""]
pub type XPLMHandleKey_f = ::std::option::Option<
    unsafe extern "C" fn(
        inWindowID: XPLMWindowID,
        inKey: ::std::os::raw::c_char,
        inFlags: XPLMKeyFlags,
        inVirtualKey: ::std::os::raw::c_char,
        inRefcon: *mut ::std::os::raw::c_void,
        losingFocus: ::std::os::raw::c_int,
    ),
>;
pub const xplm_MouseDown: _bindgen_ty_5 = 1;
pub const xplm_MouseDrag: _bindgen_ty_5 = 2;
pub const xplm_MouseUp: _bindgen_ty_5 = 3;
#[doc = " XPLMMouseStatus"]
#[doc = ""]
#[doc = " When the mouse is clicked, your mouse click routine is called repeatedly."]
#[doc = " It is first called with the mouse down message.  It is then called zero or"]
#[doc = " more times with the mouse-drag message, and finally it is called once with"]
#[doc = " the mouse up message.  All of these messages will be directed to the same"]
#[doc = " window; you are guaranteed to not receive a drag or mouse-up event without"]
#[doc = " first receiving the corresponding mouse-down."]
#[doc = ""]
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
pub type XPLMMouseStatus = ::std::os::raw::c_int;
#[doc = " XPLMHandleMouseClick_f"]
#[doc = ""]
#[doc = " You receive this call for one of three events:"]
#[doc = ""]
#[doc = " - when the user clicks the mouse button down"]
#[doc = " - (optionally) when the user drags the mouse after a down-click, but before"]
#[doc = "   the up-click"]
#[doc = " - when the user releases the down-clicked mouse button."]
#[doc = ""]
#[doc = " You receive the x and y of the click, your window, and a refcon.  Return 1"]
#[doc = " to consume the click, or 0 to pass it through."]
#[doc = ""]
#[doc = " WARNING: passing clicks through windows (as of this writing) causes mouse"]
#[doc = " tracking problems in X-Plane; do not use this feature!"]
#[doc = ""]
#[doc = " The units for x and y values match the units used in your window. Thus, for"]
#[doc = " \"modern\" windows (those created via XPLMCreateWindowEx() and compiled"]
#[doc = " against the XPLM300 library), the units are boxels, while legacy windows"]
#[doc = " will get pixels. Legacy windows have their origin in the lower left of the"]
#[doc = " main X-Plane window, while modern windows have their origin in the lower"]
#[doc = " left of the global desktop space. In both cases, x increases as you move"]
#[doc = " right, and y increases as you move up."]
#[doc = ""]
pub type XPLMHandleMouseClick_f = ::std::option::Option<
    unsafe extern "C" fn(
        inWindowID: XPLMWindowID,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        inMouse: XPLMMouseStatus,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " X-Plane manages the cursor normally, plugin does not affect the cusrsor."]
pub const xplm_CursorDefault: _bindgen_ty_6 = 0;
#[doc = " X-Plane hides the cursor."]
pub const xplm_CursorHidden: _bindgen_ty_6 = 1;
#[doc = " X-Plane shows the cursor as the default arrow."]
pub const xplm_CursorArrow: _bindgen_ty_6 = 2;
#[doc = " X-Plane shows the cursor but lets you select an OS cursor."]
pub const xplm_CursorCustom: _bindgen_ty_6 = 3;
#[doc = " XPLMCursorStatus"]
#[doc = ""]
#[doc = " XPLMCursorStatus describes how you would like X-Plane to manage the cursor."]
#[doc = " See XPLMHandleCursor_f for more info."]
#[doc = ""]
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
pub type XPLMCursorStatus = ::std::os::raw::c_int;
#[doc = " XPLMHandleCursor_f"]
#[doc = ""]
#[doc = " The SDK calls your cursor status callback when the mouse is over your"]
#[doc = " plugin window.  Return a cursor status code to indicate how you would like"]
#[doc = " X-Plane to manage the cursor.  If you return xplm_CursorDefault, the SDK"]
#[doc = " will try lower-Z-order plugin windows, then let the sim manage the cursor."]
#[doc = ""]
#[doc = " Note: you should never show or hide the cursor yourself---these APIs are"]
#[doc = " typically reference-counted and thus cannot safely and predictably be used"]
#[doc = " by the SDK.  Instead return one of xplm_CursorHidden to hide the cursor or"]
#[doc = " xplm_CursorArrow/xplm_CursorCustom to show the cursor."]
#[doc = ""]
#[doc = " If you want to implement a custom cursor by drawing a cursor in OpenGL, use"]
#[doc = " xplm_CursorHidden to hide the OS cursor and draw the cursor using a 2-d"]
#[doc = " drawing callback (after xplm_Phase_Window is probably a good choice, but"]
#[doc = " see deprecation warnings on the drawing APIs!).  If you want to use a"]
#[doc = " custom OS-based cursor, use xplm_CursorCustom to ask X-Plane to show the"]
#[doc = " cursor but not affect its image.  You can then use an OS specific call like"]
#[doc = " SetThemeCursor (Mac) or SetCursor/LoadCursor (Windows)."]
#[doc = ""]
#[doc = " The units for x and y values match the units used in your window. Thus, for"]
#[doc = " \"modern\" windows (those created via XPLMCreateWindowEx() and compiled"]
#[doc = " against the XPLM300 library), the units are boxels, while legacy windows"]
#[doc = " will get pixels. Legacy windows have their origin in the lower left of the"]
#[doc = " main X-Plane window, while modern windows have their origin in the lower"]
#[doc = " left of the global desktop space. In both cases, x increases as you move"]
#[doc = " right, and y increases as you move up."]
#[doc = ""]
pub type XPLMHandleCursor_f = ::std::option::Option<
    unsafe extern "C" fn(
        inWindowID: XPLMWindowID,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> XPLMCursorStatus,
>;
#[doc = " XPLMHandleMouseWheel_f"]
#[doc = ""]
#[doc = " The SDK calls your mouse wheel callback when one of the mouse wheels is"]
#[doc = " scrolled within your window.  Return 1 to consume the mouse wheel movement"]
#[doc = " or 0 to pass them on to a lower window.  (If your window appears opaque to"]
#[doc = " the user, you should consume mouse wheel scrolling even if it does"]
#[doc = " nothing.)  The number of \"clicks\" indicates how far the wheel was turned"]
#[doc = " since the last callback. The wheel is 0 for the vertical axis or 1 for the"]
#[doc = " horizontal axis (for OS/mouse combinations that support this)."]
#[doc = ""]
#[doc = " The units for x and y values match the units used in your window. Thus, for"]
#[doc = " \"modern\" windows (those created via XPLMCreateWindowEx() and compiled"]
#[doc = " against the XPLM300 library), the units are boxels, while legacy windows"]
#[doc = " will get pixels. Legacy windows have their origin in the lower left of the"]
#[doc = " main X-Plane window, while modern windows have their origin in the lower"]
#[doc = " left of the global desktop space. In both cases, x increases as you move"]
#[doc = " right, and y increases as you move up."]
#[doc = ""]
pub type XPLMHandleMouseWheel_f = ::std::option::Option<
    unsafe extern "C" fn(
        inWindowID: XPLMWindowID,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        wheel: ::std::os::raw::c_int,
        clicks: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The lowest layer, used for HUD-like displays while flying."]
pub const xplm_WindowLayerFlightOverlay: _bindgen_ty_7 = 0;
#[doc = " Windows that \"float\" over the sim, like the X-Plane 11 map does. If you are*"]
#[doc = " not sure which layer to create your window in, choose floating."]
pub const xplm_WindowLayerFloatingWindows: _bindgen_ty_7 = 1;
#[doc = " An interruptive modal that covers the sim with a transparent black overlay *"]
#[doc = " to draw the user's focus to the alert"]
pub const xplm_WindowLayerModal: _bindgen_ty_7 = 2;
#[doc = " \"Growl\"-style notifications that are visible in a corner of the screen,    *"]
#[doc = " even over modals"]
pub const xplm_WindowLayerGrowlNotifications: _bindgen_ty_7 = 3;
#[doc = " XPLMWindowLayer"]
#[doc = ""]
#[doc = " XPLMWindowLayer describes where in the ordering of windows X-Plane should"]
#[doc = " place a particular window. Windows in higher layers cover windows in lower"]
#[doc = " layers. So, a given window might be at the top of its particular layer, but"]
#[doc = " it might still be obscured by a window in a higher layer. (This happens"]
#[doc = " frequently when floating windows, like X-Plane's map, are covered by a"]
#[doc = " modal alert.)"]
#[doc = ""]
#[doc = " Your window's layer can only be specified when you create the window (in"]
#[doc = " the XPLMCreateWindow_t you pass to XPLMCreateWindowEx()). For this reason,"]
#[doc = " layering only applies to windows created with new X-Plane 11 GUI features."]
#[doc = " (Windows created using the older XPLMCreateWindow(), or windows compiled"]
#[doc = " against a pre-XPLM300 version of the SDK will simply be placed in the"]
#[doc = " flight overlay window layer.)"]
#[doc = ""]
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
pub type XPLMWindowLayer = ::std::os::raw::c_int;
#[doc = " X-Plane will draw no decoration for your window, and apply no automatic    *"]
#[doc = " click handlers. The window will not stop click from passing through its    *"]
#[doc = " bounds. This is suitable for \"windows\" which request, say, the full screen *"]
#[doc = " bounds, then only draw in a small portion of the available area."]
pub const xplm_WindowDecorationNone: _bindgen_ty_8 = 0;
#[doc = " The default decoration for \"native\" windows, like the map. Provides a solid*"]
#[doc = " background, as well as click handlers for resizing and dragging the window."]
pub const xplm_WindowDecorationRoundRectangle: _bindgen_ty_8 = 1;
#[doc = " X-Plane will draw no decoration for your window, nor will it provide resize*"]
#[doc = " handlers for your window edges, but it will stop clicks from passing       *"]
#[doc = " through your windows bounds."]
pub const xplm_WindowDecorationSelfDecorated: _bindgen_ty_8 = 2;
#[doc = " Like self-decorated, but with resizing; X-Plane will draw no decoration for*"]
#[doc = " your window, but it will stop clicks from passing through your windows     *"]
#[doc = " bounds, and provide automatic mouse handlers for resizing."]
pub const xplm_WindowDecorationSelfDecoratedResizable: _bindgen_ty_8 = 3;
#[doc = " XPLMWindowDecoration"]
#[doc = ""]
#[doc = " XPLMWindowDecoration describes how \"modern\" windows will be displayed. This"]
#[doc = " impacts both how X-Plane draws your window as well as certain mouse"]
#[doc = " handlers."]
#[doc = ""]
#[doc = " Your window's decoration can only be specified when you create the window"]
#[doc = " (in the XPLMCreateWindow_t you pass to XPLMCreateWindowEx())."]
#[doc = ""]
pub type _bindgen_ty_8 = ::std::os::raw::c_int;
pub type XPLMWindowDecoration = ::std::os::raw::c_int;
#[doc = " XPLMCreateWindow_t"]
#[doc = ""]
#[doc = " The XPMCreateWindow_t structure defines all of the parameters used to"]
#[doc = " create a modern window using XPLMCreateWindowEx().  The structure will be"]
#[doc = " expanded in future SDK APIs to include more features.  Always set the"]
#[doc = " structSize member to the size of your struct in bytes!"]
#[doc = ""]
#[doc = " All windows created by this function in the XPLM300 version of the API are"]
#[doc = " created with the new X-Plane 11 GUI features. This means your plugin will"]
#[doc = " get to \"know\" about the existence of X-Plane windows other than the main"]
#[doc = " window. All drawing and mouse callbacks for your window will occur in"]
#[doc = " \"boxels,\" giving your windows automatic support for high-DPI scaling in"]
#[doc = " X-Plane. In addition, your windows can opt-in to decoration with the"]
#[doc = " X-Plane 11 window styling, and you can use the"]
#[doc = " XPLMSetWindowPositioningMode() API to make your window \"popped out\" into a"]
#[doc = " first-class operating system window."]
#[doc = ""]
#[doc = " Note that this requires dealing with your window's bounds in \"global"]
#[doc = " desktop\" positioning units, rather than the traditional panel coordinate"]
#[doc = " system. In global desktop coordinates, the main X-Plane window may not have"]
#[doc = " its origin at coordinate (0, 0), and your own window may have negative"]
#[doc = " coordinates. Assuming you don't implicitly assume (0, 0) as your origin,"]
#[doc = " the only API change you should need is to start using"]
#[doc = " XPLMGetMouseLocationGlobal() rather than XPLMGetMouseLocation(), and"]
#[doc = " XPLMGetScreenBoundsGlobal() instead of XPLMGetScreenSize()."]
#[doc = ""]
#[doc = " If you ask to be decorated as a floating window, you'll get the blue window"]
#[doc = " control bar and blue backing that you see in X-Plane 11's normal \"floating\""]
#[doc = " windows (like the map)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPLMCreateWindow_t {
    #[doc = " Used to inform XPLMCreateWindowEx() of the SDK version you compiled        *"]
    #[doc = " against; should always be set to sizeof(XPLMCreateWindow_t)"]
    pub structSize: ::std::os::raw::c_int,
    #[doc = " Left bound, in global desktop boxels"]
    pub left: ::std::os::raw::c_int,
    #[doc = " Top bound, in global desktop boxels"]
    pub top: ::std::os::raw::c_int,
    #[doc = " Right bound, in global desktop boxels"]
    pub right: ::std::os::raw::c_int,
    #[doc = " Bottom bound, in global desktop boxels"]
    pub bottom: ::std::os::raw::c_int,
    pub visible: ::std::os::raw::c_int,
    pub drawWindowFunc: XPLMDrawWindow_f,
    #[doc = " A callback to handle the user left-clicking within your window (or NULL to *"]
    #[doc = " ignore left clicks)"]
    pub handleMouseClickFunc: XPLMHandleMouseClick_f,
    pub handleKeyFunc: XPLMHandleKey_f,
    pub handleCursorFunc: XPLMHandleCursor_f,
    pub handleMouseWheelFunc: XPLMHandleMouseWheel_f,
    #[doc = " A reference which will be passed into each of your window callbacks. Use   *"]
    #[doc = " this to pass information to yourself as needed."]
    pub refcon: *mut ::std::os::raw::c_void,
    #[doc = " Specifies the type of X-Plane 11-style \"wrapper\" you want around your      *"]
    #[doc = " window, if any"]
    pub decorateAsFloatingWindow: XPLMWindowDecoration,
    pub layer: XPLMWindowLayer,
    #[doc = " A callback to handle the user right-clicking within your window (or NULL to*"]
    #[doc = " ignore right clicks)"]
    pub handleRightClickFunc: XPLMHandleMouseClick_f,
}
#[test]
fn bindgen_test_layout_XPLMCreateWindow_t() {
    const UNINIT: ::std::mem::MaybeUninit<XPLMCreateWindow_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XPLMCreateWindow_t>(),
        88usize,
        concat!("Size of: ", stringify!(XPLMCreateWindow_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XPLMCreateWindow_t>(),
        8usize,
        concat!("Alignment of ", stringify!(XPLMCreateWindow_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visible) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawWindowFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(drawWindowFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleMouseClickFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(handleMouseClickFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleKeyFunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(handleKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleCursorFunc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(handleCursorFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleMouseWheelFunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(handleMouseWheelFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcon) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(refcon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decorateAsFloatingWindow) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(decorateAsFloatingWindow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handleRightClickFunc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateWindow_t),
            "::",
            stringify!(handleRightClickFunc)
        )
    );
}
extern "C" {
    #[doc = " XPLMCreateWindowEx"]
    #[doc = ""]
    #[doc = " This routine creates a new \"modern\" window. You pass in an"]
    #[doc = " XPLMCreateWindow_t structure with all of the fields set in.  You must set"]
    #[doc = " the structSize of the structure to the size of the actual structure you"]
    #[doc = " used.  Also, you must provide functions for every callback---you may not"]
    #[doc = " leave them null!  (If you do not support the cursor or mouse wheel, use"]
    #[doc = " functions that return the default values.)"]
    #[doc = ""]
    pub fn XPLMCreateWindowEx(inParams: *mut XPLMCreateWindow_t) -> XPLMWindowID;
}
extern "C" {
    #[doc = " XPLMCreateWindow"]
    #[doc = ""]
    #[doc = " Deprecated as of XPLM300."]
    #[doc = ""]
    #[doc = " This routine creates a new legacy window. Unlike modern windows (created"]
    #[doc = " via XPLMCreateWindowEx()), legacy windows do not have access to X-Plane 11"]
    #[doc = " features like automatic scaling for high-DPI screens, native window styles,"]
    #[doc = " or support for being \"popped out\" into first-class operating system"]
    #[doc = " windows."]
    #[doc = ""]
    #[doc = " Pass in the dimensions and offsets to the window's bottom left corner from"]
    #[doc = " the bottom left of the screen.  You can specify whether the window is"]
    #[doc = " initially visible or not.  Also, you pass in three callbacks to run the"]
    #[doc = " window and a refcon.  This function returns a window ID you can use to"]
    #[doc = " refer to the new window."]
    #[doc = ""]
    #[doc = " NOTE: Legacy windows do not have \"frames\"; you are responsible for drawing"]
    #[doc = " the background and frame of the window.  Higher level libraries have"]
    #[doc = " routines which make this easy."]
    #[doc = ""]
    pub fn XPLMCreateWindow(
        inLeft: ::std::os::raw::c_int,
        inTop: ::std::os::raw::c_int,
        inRight: ::std::os::raw::c_int,
        inBottom: ::std::os::raw::c_int,
        inIsVisible: ::std::os::raw::c_int,
        inDrawCallback: XPLMDrawWindow_f,
        inKeyCallback: XPLMHandleKey_f,
        inMouseCallback: XPLMHandleMouseClick_f,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> XPLMWindowID;
}
extern "C" {
    #[doc = " XPLMDestroyWindow"]
    #[doc = ""]
    #[doc = " This routine destroys a window.  The window's callbacks are not called"]
    #[doc = " after this call. Keyboard focus is removed from the window before"]
    #[doc = " destroying it."]
    #[doc = ""]
    pub fn XPLMDestroyWindow(inWindowID: XPLMWindowID);
}
extern "C" {
    #[doc = " XPLMGetScreenSize"]
    #[doc = ""]
    #[doc = " This routine returns the size of the main X-Plane OpenGL window in pixels."]
    #[doc = " This number can be used to get a rough idea of the amount of detail the"]
    #[doc = " user will be able to see when drawing in 3-d."]
    #[doc = ""]
    pub fn XPLMGetScreenSize(
        outWidth: *mut ::std::os::raw::c_int,
        outHeight: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetScreenBoundsGlobal"]
    #[doc = ""]
    #[doc = " This routine returns the bounds of the \"global\" X-Plane desktop, in boxels."]
    #[doc = " Unlike the non-global version XPLMGetScreenSize(), this is multi-monitor"]
    #[doc = " aware. There are three primary consequences of multimonitor awareness."]
    #[doc = ""]
    #[doc = " First, if the user is running X-Plane in full-screen on two or more"]
    #[doc = " monitors (typically configured using one full-screen window per monitor),"]
    #[doc = " the global desktop will be sized to include all X-Plane windows."]
    #[doc = ""]
    #[doc = " Second, the origin of the screen coordinates is not guaranteed to be (0,"]
    #[doc = " 0). Suppose the user has two displays side-by-side, both running at 1080p."]
    #[doc = " Suppose further that they've configured their OS to make the left display"]
    #[doc = " their \"primary\" monitor, and that X-Plane is running in full-screen on"]
    #[doc = " their right monitor only. In this case, the global desktop bounds would be"]
    #[doc = " the rectangle from (1920, 0) to (3840, 1080). If the user later asked"]
    #[doc = " X-Plane to draw on their primary monitor as well, the bounds would change"]
    #[doc = " to (0, 0) to (3840, 1080)."]
    #[doc = ""]
    #[doc = " Finally, if the usable area of the virtual desktop is not a perfect"]
    #[doc = " rectangle (for instance, because the monitors have different resolutions or"]
    #[doc = " because one monitor is configured in the operating system to be above and"]
    #[doc = " to the right of the other), the global desktop will include any wasted"]
    #[doc = " space. Thus, if you have two 1080p monitors, and monitor 2 is configured to"]
    #[doc = " have its bottom left touch monitor 1's upper right, your global desktop"]
    #[doc = " area would be the rectangle from (0, 0) to (3840, 2160)."]
    #[doc = ""]
    #[doc = " Note that popped-out windows (windows drawn in their own operating system"]
    #[doc = " windows, rather than \"floating\" within X-Plane) are not included in these"]
    #[doc = " bounds."]
    #[doc = ""]
    pub fn XPLMGetScreenBoundsGlobal(
        outLeft: *mut ::std::os::raw::c_int,
        outTop: *mut ::std::os::raw::c_int,
        outRight: *mut ::std::os::raw::c_int,
        outBottom: *mut ::std::os::raw::c_int,
    );
}
#[doc = " XPLMReceiveMonitorBoundsGlobal_f"]
#[doc = ""]
#[doc = " This function is informed of the global bounds (in boxels) of a particular"]
#[doc = " monitor within the X-Plane global desktop space. Note that X-Plane must be"]
#[doc = " running in full screen on a monitor in order for that monitor to be passed"]
#[doc = " to you in this callback."]
#[doc = ""]
pub type XPLMReceiveMonitorBoundsGlobal_f = ::std::option::Option<
    unsafe extern "C" fn(
        inMonitorIndex: ::std::os::raw::c_int,
        inLeftBx: ::std::os::raw::c_int,
        inTopBx: ::std::os::raw::c_int,
        inRightBx: ::std::os::raw::c_int,
        inBottomBx: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " XPLMGetAllMonitorBoundsGlobal"]
    #[doc = ""]
    #[doc = " This routine immediately calls you back with the bounds (in boxels) of each"]
    #[doc = " full-screen X-Plane window within the X-Plane global desktop space. Note"]
    #[doc = " that if a monitor is *not* covered by an X-Plane window, you cannot get its"]
    #[doc = " bounds this way. Likewise, monitors with only an X-Plane window (not in"]
    #[doc = " full-screen mode) will not be included."]
    #[doc = ""]
    #[doc = " If X-Plane is running in full-screen and your monitors are of the same size"]
    #[doc = " and configured contiguously in the OS, then the combined global bounds of"]
    #[doc = " all full-screen monitors will match the total global desktop bounds, as"]
    #[doc = " returned by XPLMGetScreenBoundsGlobal(). (Of course, if X-Plane is running"]
    #[doc = " in windowed mode, this will not be the case. Likewise, if you have"]
    #[doc = " differently sized monitors, the global desktop space will include wasted"]
    #[doc = " space.)"]
    #[doc = ""]
    #[doc = " Note that this function's monitor indices match those provided by"]
    #[doc = " XPLMGetAllMonitorBoundsOS(), but the coordinates are different (since the"]
    #[doc = " X-Plane global desktop may not match the operating system's global desktop,"]
    #[doc = " and one X-Plane boxel may be larger than one pixel due to 150% or 200%"]
    #[doc = " scaling)."]
    #[doc = ""]
    pub fn XPLMGetAllMonitorBoundsGlobal(
        inMonitorBoundsCallback: XPLMReceiveMonitorBoundsGlobal_f,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
#[doc = " XPLMReceiveMonitorBoundsOS_f"]
#[doc = ""]
#[doc = " This function is informed of the global bounds (in pixels) of a particular"]
#[doc = " monitor within the operating system's global desktop space. Note that a"]
#[doc = " monitor index being passed to you here does not indicate that X-Plane is"]
#[doc = " running in full screen on this monitor, or even that any X-Plane windows"]
#[doc = " exist on this monitor."]
#[doc = ""]
pub type XPLMReceiveMonitorBoundsOS_f = ::std::option::Option<
    unsafe extern "C" fn(
        inMonitorIndex: ::std::os::raw::c_int,
        inLeftPx: ::std::os::raw::c_int,
        inTopPx: ::std::os::raw::c_int,
        inRightPx: ::std::os::raw::c_int,
        inBottomPx: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " XPLMGetAllMonitorBoundsOS"]
    #[doc = ""]
    #[doc = " This routine immediately calls you back with the bounds (in pixels) of each"]
    #[doc = " monitor within the operating system's global desktop space. Note that"]
    #[doc = " unlike XPLMGetAllMonitorBoundsGlobal(), this may include monitors that have"]
    #[doc = " no X-Plane window on them."]
    #[doc = ""]
    #[doc = " Note that this function's monitor indices match those provided by"]
    #[doc = " XPLMGetAllMonitorBoundsGlobal(), but the coordinates are different (since"]
    #[doc = " the X-Plane global desktop may not match the operating system's global"]
    #[doc = " desktop, and one X-Plane boxel may be larger than one pixel)."]
    #[doc = ""]
    pub fn XPLMGetAllMonitorBoundsOS(
        inMonitorBoundsCallback: XPLMReceiveMonitorBoundsOS_f,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMGetMouseLocation"]
    #[doc = ""]
    #[doc = " Deprecated in XPLM300. Modern windows should use"]
    #[doc = " XPLMGetMouseLocationGlobal() instead."]
    #[doc = ""]
    #[doc = " This routine returns the current mouse location in pixels relative to the"]
    #[doc = " main X-Plane window. The bottom left corner of the main window is (0, 0)."]
    #[doc = " Pass NULL to not receive info about either parameter."]
    #[doc = ""]
    #[doc = " Because this function gives the mouse position relative to the main X-Plane"]
    #[doc = " window (rather than in global bounds), this function should only be used by"]
    #[doc = " legacy windows. Modern windows should instead get the mouse position in"]
    #[doc = " global desktop coordinates using XPLMGetMouseLocationGlobal()."]
    #[doc = ""]
    #[doc = " Note that unlike XPLMGetMouseLocationGlobal(), if the mouse goes outside"]
    #[doc = " the user's main monitor (for instance, to a pop out window or a secondary"]
    #[doc = " monitor), this function will not reflect it."]
    #[doc = ""]
    pub fn XPLMGetMouseLocation(outX: *mut ::std::os::raw::c_int, outY: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMGetMouseLocationGlobal"]
    #[doc = ""]
    #[doc = " Returns the current mouse location in global desktop boxels. Unlike"]
    #[doc = " XPLMGetMouseLocation(), the bottom left of the main X-Plane window is not"]
    #[doc = " guaranteed to be (0, 0)---instead, the origin is the lower left of the"]
    #[doc = " entire global desktop space. In addition, this routine gives the real mouse"]
    #[doc = " location when the mouse goes to X-Plane windows other than the primary"]
    #[doc = " display. Thus, it can be used with both pop-out windows and secondary"]
    #[doc = " monitors."]
    #[doc = ""]
    #[doc = " This is the mouse location function to use with modern windows (i.e., those"]
    #[doc = " created by XPLMCreateWindowEx())."]
    #[doc = ""]
    #[doc = " Pass NULL to not receive info about either parameter."]
    #[doc = ""]
    pub fn XPLMGetMouseLocationGlobal(
        outX: *mut ::std::os::raw::c_int,
        outY: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetWindowGeometry"]
    #[doc = ""]
    #[doc = " This routine returns the position and size of a window. The units and"]
    #[doc = " coordinate system vary depending on the type of window you have."]
    #[doc = ""]
    #[doc = " If this is a legacy window (one compiled against a pre-XPLM300 version of"]
    #[doc = " the SDK, or an XPLM300 window that was not created using"]
    #[doc = " XPLMCreateWindowEx()), the units are pixels relative to the main X-Plane"]
    #[doc = " display."]
    #[doc = ""]
    #[doc = " If, on the other hand, this is a new X-Plane 11-style window (compiled"]
    #[doc = " against the XPLM300 SDK and created using XPLMCreateWindowEx()), the units"]
    #[doc = " are global desktop boxels."]
    #[doc = ""]
    #[doc = " Pass NULL to not receive any paramter."]
    #[doc = ""]
    pub fn XPLMGetWindowGeometry(
        inWindowID: XPLMWindowID,
        outLeft: *mut ::std::os::raw::c_int,
        outTop: *mut ::std::os::raw::c_int,
        outRight: *mut ::std::os::raw::c_int,
        outBottom: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMSetWindowGeometry"]
    #[doc = ""]
    #[doc = " This routine allows you to set the position and size of a window."]
    #[doc = ""]
    #[doc = " The units and coordinate system match those of XPLMGetWindowGeometry()."]
    #[doc = " That is, modern windows use global desktop boxel coordinates, while legacy"]
    #[doc = " windows use pixels relative to the main X-Plane display."]
    #[doc = ""]
    #[doc = " Note that this only applies to \"floating\" windows (that is, windows that"]
    #[doc = " are drawn within the X-Plane simulation windows, rather than being \"popped"]
    #[doc = " out\" into their own first-class operating system windows). To set the"]
    #[doc = " position of windows whose positioning mode is xplm_WindowPopOut, you'll"]
    #[doc = " need to instead use XPLMSetWindowGeometryOS()."]
    #[doc = ""]
    pub fn XPLMSetWindowGeometry(
        inWindowID: XPLMWindowID,
        inLeft: ::std::os::raw::c_int,
        inTop: ::std::os::raw::c_int,
        inRight: ::std::os::raw::c_int,
        inBottom: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetWindowGeometryOS"]
    #[doc = ""]
    #[doc = " This routine returns the position and size of a \"popped out\" window (i.e.,"]
    #[doc = " a window whose positioning mode is xplm_WindowPopOut), in operating system"]
    #[doc = " pixels.  Pass NULL to not receive any parameter."]
    #[doc = ""]
    pub fn XPLMGetWindowGeometryOS(
        inWindowID: XPLMWindowID,
        outLeft: *mut ::std::os::raw::c_int,
        outTop: *mut ::std::os::raw::c_int,
        outRight: *mut ::std::os::raw::c_int,
        outBottom: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMSetWindowGeometryOS"]
    #[doc = ""]
    #[doc = " This routine allows you to set the position and size, in operating system"]
    #[doc = " pixel coordinates, of a popped out window (that is, a window whose"]
    #[doc = " positioning mode is xplm_WindowPopOut, which exists outside the X-Plane"]
    #[doc = " simulation window, in its own first-class operating system window)."]
    #[doc = ""]
    #[doc = " Note that you are responsible for ensuring both that your window is popped"]
    #[doc = " out (using XPLMWindowIsPoppedOut()) and that a monitor really exists at the"]
    #[doc = " OS coordinates you provide (using XPLMGetAllMonitorBoundsOS())."]
    #[doc = ""]
    pub fn XPLMSetWindowGeometryOS(
        inWindowID: XPLMWindowID,
        inLeft: ::std::os::raw::c_int,
        inTop: ::std::os::raw::c_int,
        inRight: ::std::os::raw::c_int,
        inBottom: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetWindowGeometryVR"]
    #[doc = ""]
    #[doc = " Returns the width and height, in boxels, of a window in VR. Note that you"]
    #[doc = " are responsible for ensuring your window is in VR (using"]
    #[doc = " XPLMWindowIsInVR())."]
    #[doc = ""]
    pub fn XPLMGetWindowGeometryVR(
        inWindowID: XPLMWindowID,
        outWidthBoxels: *mut ::std::os::raw::c_int,
        outHeightBoxels: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMSetWindowGeometryVR"]
    #[doc = ""]
    #[doc = " This routine allows you to set the size, in boxels, of a window in VR (that"]
    #[doc = " is, a window whose positioning mode is xplm_WindowVR)."]
    #[doc = ""]
    #[doc = " Note that you are responsible for ensuring your window is in VR (using"]
    #[doc = " XPLMWindowIsInVR())."]
    #[doc = ""]
    pub fn XPLMSetWindowGeometryVR(
        inWindowID: XPLMWindowID,
        widthBoxels: ::std::os::raw::c_int,
        heightBoxels: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGetWindowIsVisible"]
    #[doc = ""]
    #[doc = " Returns true (1) if the specified window is visible."]
    #[doc = ""]
    pub fn XPLMGetWindowIsVisible(inWindowID: XPLMWindowID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetWindowIsVisible"]
    #[doc = ""]
    #[doc = " This routine shows or hides a window."]
    #[doc = ""]
    pub fn XPLMSetWindowIsVisible(inWindowID: XPLMWindowID, inIsVisible: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMWindowIsPoppedOut"]
    #[doc = ""]
    #[doc = " True if this window has been popped out (making it a first-class window in"]
    #[doc = " the operating system), which in turn is true if and only if you have set"]
    #[doc = " the window's positioning mode to xplm_WindowPopOut."]
    #[doc = ""]
    #[doc = " Only applies to modern windows. (Windows created using the deprecated"]
    #[doc = " XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of"]
    #[doc = " the SDK cannot be popped out.)"]
    #[doc = ""]
    pub fn XPLMWindowIsPoppedOut(inWindowID: XPLMWindowID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMWindowIsInVR"]
    #[doc = ""]
    #[doc = " True if this window has been moved to the virtual reality (VR) headset,"]
    #[doc = " which in turn is true if and only if you have set the window's positioning"]
    #[doc = " mode to xplm_WindowVR."]
    #[doc = ""]
    #[doc = " Only applies to modern windows. (Windows created using the deprecated"]
    #[doc = " XPLMCreateWindow(), or windows compiled against a pre-XPLM301 version of"]
    #[doc = " the SDK cannot be moved to VR.)"]
    #[doc = ""]
    pub fn XPLMWindowIsInVR(inWindowID: XPLMWindowID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetWindowGravity"]
    #[doc = ""]
    #[doc = " A window's \"gravity\" controls how the window shifts as the whole X-Plane"]
    #[doc = " window resizes. A gravity of 1 means the window maintains its positioning"]
    #[doc = " relative to the right or top edges, 0 the left/bottom, and 0.5 keeps it"]
    #[doc = " centered."]
    #[doc = ""]
    #[doc = " Default gravity is (0, 1, 0, 1), meaning your window will maintain its"]
    #[doc = " position relative to the top left and will not change size as its"]
    #[doc = " containing window grows."]
    #[doc = ""]
    #[doc = " If you wanted, say, a window that sticks to the top of the screen (with a"]
    #[doc = " constant height), but which grows to take the full width of the window, you"]
    #[doc = " would pass (0, 1, 1, 1). Because your left and right edges would maintain"]
    #[doc = " their positioning relative to their respective edges of the screen, the"]
    #[doc = " whole width of your window would change with the X-Plane window."]
    #[doc = ""]
    #[doc = " Only applies to modern windows. (Windows created using the deprecated"]
    #[doc = " XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of"]
    #[doc = " the SDK will simply get the default gravity.)"]
    #[doc = ""]
    pub fn XPLMSetWindowGravity(
        inWindowID: XPLMWindowID,
        inLeftGravity: f32,
        inTopGravity: f32,
        inRightGravity: f32,
        inBottomGravity: f32,
    );
}
extern "C" {
    #[doc = " XPLMSetWindowResizingLimits"]
    #[doc = ""]
    #[doc = " Sets the minimum and maximum size of the client rectangle of the given"]
    #[doc = " window. (That is, it does not include any window styling that you might"]
    #[doc = " have asked X-Plane to apply on your behalf.) All resizing operations are"]
    #[doc = " constrained to these sizes."]
    #[doc = ""]
    #[doc = " Only applies to modern windows. (Windows created using the deprecated"]
    #[doc = " XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of"]
    #[doc = " the SDK will have no minimum or maximum size.)"]
    #[doc = ""]
    pub fn XPLMSetWindowResizingLimits(
        inWindowID: XPLMWindowID,
        inMinWidthBoxels: ::std::os::raw::c_int,
        inMinHeightBoxels: ::std::os::raw::c_int,
        inMaxWidthBoxels: ::std::os::raw::c_int,
        inMaxHeightBoxels: ::std::os::raw::c_int,
    );
}
#[doc = " The default positioning mode. Set the window geometry and its future       *"]
#[doc = " position will be determined by its window gravity, resizing limits, and    *"]
#[doc = " user interactions."]
pub const xplm_WindowPositionFree: _bindgen_ty_9 = 0;
#[doc = " Keep the window centered on the monitor you specify"]
pub const xplm_WindowCenterOnMonitor: _bindgen_ty_9 = 1;
#[doc = " Keep the window full screen on the monitor you specify"]
pub const xplm_WindowFullScreenOnMonitor: _bindgen_ty_9 = 2;
#[doc = " Like gui_window_full_screen_on_monitor, but stretches over *all* monitors  *"]
#[doc = " and popout windows. This is an obscure one... unless you have a very good  *"]
#[doc = " reason to need it, you probably don't!"]
pub const xplm_WindowFullScreenOnAllMonitors: _bindgen_ty_9 = 3;
#[doc = " A first-class window in the operating system, completely separate from the *"]
#[doc = " X-Plane window(s)"]
pub const xplm_WindowPopOut: _bindgen_ty_9 = 4;
#[doc = " A floating window visible on the VR headset"]
pub const xplm_WindowVR: _bindgen_ty_9 = 5;
#[doc = " XPLMWindowPositioningMode"]
#[doc = ""]
#[doc = " XPLMWindowPositionMode describes how X-Plane will position your window on"]
#[doc = " the user's screen. X-Plane will maintain this positioning mode even as the"]
#[doc = " user resizes their window or adds/removes full-screen monitors."]
#[doc = ""]
#[doc = " Positioning mode can only be set for \"modern\" windows (that is, windows"]
#[doc = " created using XPLMCreateWindowEx() and compiled against the XPLM300 SDK)."]
#[doc = " Windows created using the deprecated XPLMCreateWindow(), or windows"]
#[doc = " compiled against a pre-XPLM300 version of the SDK will simply get the"]
#[doc = " \"free\" positioning mode."]
#[doc = ""]
pub type _bindgen_ty_9 = ::std::os::raw::c_int;
pub type XPLMWindowPositioningMode = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMSetWindowPositioningMode"]
    #[doc = ""]
    #[doc = " Sets the policy for how X-Plane will position your window."]
    #[doc = ""]
    #[doc = " Some positioning modes apply to a particular monitor. For those modes, you"]
    #[doc = " can pass a negative monitor index to position the window on the main"]
    #[doc = " X-Plane monitor (the screen with the X-Plane menu bar at the top). Or, if"]
    #[doc = " you have a specific monitor you want to position your window on, you can"]
    #[doc = " pass a real monitor index as received from, e.g.,"]
    #[doc = " XPLMGetAllMonitorBoundsOS()."]
    #[doc = ""]
    #[doc = " Only applies to modern windows. (Windows created using the deprecated"]
    #[doc = " XPLMCreateWindow(), or windows compiled against a pre-XPLM300 version of"]
    #[doc = " the SDK will always use xplm_WindowPositionFree.)"]
    #[doc = ""]
    pub fn XPLMSetWindowPositioningMode(
        inWindowID: XPLMWindowID,
        inPositioningMode: XPLMWindowPositioningMode,
        inMonitorIndex: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMSetWindowTitle"]
    #[doc = ""]
    #[doc = " Sets the name for a window. This only applies to windows that opted-in to"]
    #[doc = " styling as an X-Plane 11 floating window (i.e., with styling mode"]
    #[doc = " xplm_WindowDecorationRoundRectangle) when they were created using"]
    #[doc = " XPLMCreateWindowEx()."]
    #[doc = ""]
    pub fn XPLMSetWindowTitle(
        inWindowID: XPLMWindowID,
        inWindowTitle: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " XPLMGetWindowRefCon"]
    #[doc = ""]
    #[doc = " Returns a window's reference constant, the unique value you can use for"]
    #[doc = " your own purposes."]
    #[doc = ""]
    pub fn XPLMGetWindowRefCon(inWindowID: XPLMWindowID) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " XPLMSetWindowRefCon"]
    #[doc = ""]
    #[doc = " Sets a window's reference constant.  Use this to pass data to yourself in"]
    #[doc = " the callbacks."]
    #[doc = ""]
    pub fn XPLMSetWindowRefCon(inWindowID: XPLMWindowID, inRefcon: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " XPLMTakeKeyboardFocus"]
    #[doc = ""]
    #[doc = " This routine gives a specific window keyboard focus.  Keystrokes will be"]
    #[doc = " sent to that window.  Pass a window ID of 0 to remove keyboard focus from"]
    #[doc = " any plugin-created windows and instead pass keyboard strokes directly to"]
    #[doc = " X-Plane."]
    #[doc = ""]
    pub fn XPLMTakeKeyboardFocus(inWindow: XPLMWindowID);
}
extern "C" {
    #[doc = " XPLMHasKeyboardFocus"]
    #[doc = ""]
    #[doc = " Returns true (1) if the indicated window has keyboard focus. Pass a window"]
    #[doc = " ID of 0 to see if no plugin window has focus, and all keystrokes will go"]
    #[doc = " directly to X-Plane."]
    #[doc = ""]
    pub fn XPLMHasKeyboardFocus(inWindow: XPLMWindowID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMBringWindowToFront"]
    #[doc = ""]
    #[doc = " This routine brings the window to the front of the Z-order for its layer."]
    #[doc = " Windows are brought to the front automatically when they are created."]
    #[doc = " Beyond that, you should make sure you are front before handling mouse"]
    #[doc = " clicks."]
    #[doc = ""]
    #[doc = " Note that this only brings your window to the front of its layer"]
    #[doc = " (XPLMWindowLayer). Thus, if you have a window in the floating window layer"]
    #[doc = " (xplm_WindowLayerFloatingWindows), but there is a modal window (in layer"]
    #[doc = " xplm_WindowLayerModal) above you, you would still not be the true frontmost"]
    #[doc = " window after calling this. (After all, the window layers are strictly"]
    #[doc = " ordered, and no window in a lower layer can ever be above any window in a"]
    #[doc = " higher one.)"]
    #[doc = ""]
    pub fn XPLMBringWindowToFront(inWindow: XPLMWindowID);
}
extern "C" {
    #[doc = " XPLMIsWindowInFront"]
    #[doc = ""]
    #[doc = " This routine returns true if the window you passed in is the frontmost"]
    #[doc = " visible window in its layer (XPLMWindowLayer)."]
    #[doc = ""]
    #[doc = " Thus, if you have a window at the front of the floating window layer"]
    #[doc = " (xplm_WindowLayerFloatingWindows), this will return true even if there is a"]
    #[doc = " modal window (in layer xplm_WindowLayerModal) above you. (Not to worry,"]
    #[doc = " though: in such a case, X-Plane will not pass clicks or keyboard input down"]
    #[doc = " to your layer until the window above stops \"eating\" the input.)"]
    #[doc = ""]
    #[doc = " Note that legacy windows are always placed in layer"]
    #[doc = " xplm_WindowLayerFlightOverlay, while modern-style windows default to"]
    #[doc = " xplm_WindowLayerFloatingWindows. This means it's perfectly consistent to"]
    #[doc = " have two different plugin-created windows (one legacy, one modern) *both*"]
    #[doc = " be in the front (of their different layers!) at the same time."]
    #[doc = ""]
    pub fn XPLMIsWindowInFront(inWindow: XPLMWindowID) -> ::std::os::raw::c_int;
}
#[doc = " XPLMKeySniffer_f"]
#[doc = ""]
#[doc = " This is the prototype for a low level key-sniffing function.  Window-based"]
#[doc = " UI _should not use this_!  The windowing system provides high-level"]
#[doc = " mediated keyboard access, via the callbacks you attach to your"]
#[doc = " XPLMCreateWindow_t. By comparison, the key sniffer provides low level"]
#[doc = " keyboard access."]
#[doc = ""]
#[doc = " Key sniffers are provided to allow libraries to provide non-windowed user"]
#[doc = " interaction.  For example, the MUI library uses a key sniffer to do pop-up"]
#[doc = " text entry."]
#[doc = ""]
#[doc = " Return 1 to pass the key on to the next sniffer, the window manager,"]
#[doc = " X-Plane, or whomever is down stream.  Return 0 to consume the key."]
#[doc = ""]
#[doc = " Warning: this API declares virtual keys as a signed character; however the"]
#[doc = " VKEY #define macros in XPLMDefs.h define the vkeys using unsigned values"]
#[doc = " (that is 0x80 instead of -0x80).  So you may need to cast the incoming vkey"]
#[doc = " to an unsigned char to get correct comparisons in C."]
#[doc = ""]
pub type XPLMKeySniffer_f = ::std::option::Option<
    unsafe extern "C" fn(
        inChar: ::std::os::raw::c_char,
        inFlags: XPLMKeyFlags,
        inVirtualKey: ::std::os::raw::c_char,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " XPLMRegisterKeySniffer"]
    #[doc = ""]
    #[doc = " This routine registers a key sniffing callback.  You specify whether you"]
    #[doc = " want to sniff before the window system, or only sniff keys the window"]
    #[doc = " system does not consume.  You should ALMOST ALWAYS sniff non-control keys"]
    #[doc = " after the window system.  When the window system consumes a key, it is"]
    #[doc = " because the user has \"focused\" a window.  Consuming the key or taking"]
    #[doc = " action based on the key will produce very weird results.  Returns"]
    #[doc = " 1 if successful."]
    #[doc = ""]
    pub fn XPLMRegisterKeySniffer(
        inCallback: XPLMKeySniffer_f,
        inBeforeWindows: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMUnregisterKeySniffer"]
    #[doc = ""]
    #[doc = " This routine unregisters a key sniffer.  You must unregister a key sniffer"]
    #[doc = " for every time you register one with the exact same signature.  Returns 1"]
    #[doc = " if successful."]
    #[doc = ""]
    pub fn XPLMUnregisterKeySniffer(
        inCallback: XPLMKeySniffer_f,
        inBeforeWindows: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " XPLMHotKey_f"]
#[doc = ""]
#[doc = " Your hot key callback simply takes a pointer of your choosing."]
#[doc = ""]
pub type XPLMHotKey_f =
    ::std::option::Option<unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void)>;
#[doc = " XPLMHotKeyID"]
#[doc = ""]
#[doc = " An opaque ID used to identify a hot key."]
#[doc = ""]
pub type XPLMHotKeyID = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " XPLMRegisterHotKey"]
    #[doc = ""]
    #[doc = " This routine registers a hot key.  You specify your preferred key stroke"]
    #[doc = " virtual key/flag combination, a description of what your callback does (so"]
    #[doc = " other plug-ins can describe the plug-in to the user for remapping) and a"]
    #[doc = " callback function and opaque pointer to pass in).  A new hot key ID is"]
    #[doc = " returned.  During execution, the actual key associated with your hot key"]
    #[doc = " may change, but you are insulated from this."]
    #[doc = ""]
    pub fn XPLMRegisterHotKey(
        inVirtualKey: ::std::os::raw::c_char,
        inFlags: XPLMKeyFlags,
        inDescription: *const ::std::os::raw::c_char,
        inCallback: XPLMHotKey_f,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> XPLMHotKeyID;
}
extern "C" {
    #[doc = " XPLMUnregisterHotKey"]
    #[doc = ""]
    #[doc = " Unregisters a hot key.  You can only unregister your own hot keys."]
    #[doc = ""]
    pub fn XPLMUnregisterHotKey(inHotKey: XPLMHotKeyID);
}
extern "C" {
    #[doc = " XPLMCountHotKeys"]
    #[doc = ""]
    #[doc = " Returns the number of current hot keys."]
    #[doc = ""]
    pub fn XPLMCountHotKeys() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMGetNthHotKey"]
    #[doc = ""]
    #[doc = " Returns a hot key by index, for iteration on all hot keys."]
    #[doc = ""]
    pub fn XPLMGetNthHotKey(inIndex: ::std::os::raw::c_int) -> XPLMHotKeyID;
}
extern "C" {
    #[doc = " XPLMGetHotKeyInfo"]
    #[doc = ""]
    #[doc = " Returns information about the hot key.  Return NULL for any parameter you"]
    #[doc = " don't want info about.  The description should be at least 512 chars long."]
    #[doc = ""]
    pub fn XPLMGetHotKeyInfo(
        inHotKey: XPLMHotKeyID,
        outVirtualKey: *mut ::std::os::raw::c_char,
        outFlags: *mut XPLMKeyFlags,
        outDescription: *mut ::std::os::raw::c_char,
        outPlugin: *mut XPLMPluginID,
    );
}
extern "C" {
    #[doc = " XPLMSetHotKeyCombination"]
    #[doc = ""]
    #[doc = " Remaps a hot key's keystrokes.  You may remap another plugin's keystrokes."]
    #[doc = ""]
    pub fn XPLMSetHotKeyCombination(
        inHotKey: XPLMHotKeyID,
        inVirtualKey: ::std::os::raw::c_char,
        inFlags: XPLMKeyFlags,
    );
}
#[doc = " The bitmap that contains window outlines, button outlines, fonts, etc."]
pub const xplm_Tex_GeneralInterface: _bindgen_ty_10 = 0;
#[doc = " XPLMTextureID"]
#[doc = ""]
#[doc = " XPLM Texture IDs name well-known textures in the sim for you to use. This"]
#[doc = " allows you to recycle textures from X-Plane, saving VRAM."]
#[doc = ""]
#[doc = " *Warning*: do not use these enums.  The only remaining use they have is to"]
#[doc = "  access the legacy compatibility v10 UI texture; if you need this, get it"]
#[doc = "  via the Widgets library."]
#[doc = ""]
pub type _bindgen_ty_10 = ::std::os::raw::c_int;
pub type XPLMTextureID = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMSetGraphicsState"]
    #[doc = ""]
    #[doc = " XPLMSetGraphicsState changes OpenGL's fixed function pipeline state.  You"]
    #[doc = " are not responsible for restoring any state that is accessed via"]
    #[doc = " XPLMSetGraphicsState, but you are responsible for not accessing this state"]
    #[doc = " directly."]
    #[doc = ""]
    #[doc = " - inEnableFog - enables or disables fog, equivalent to: glEnable(GL_FOG);"]
    #[doc = " - inNumberTexUnits - enables or disables a number of multitexturing units."]
    #[doc = "   If the number is 0, 2d texturing is disabled entirely, as in"]
    #[doc = "   glDisable(GL_TEXTURE_2D);  Otherwise, 2d texturing is enabled, and a"]
    #[doc = "   number of multitexturing units are enabled sequentially, starting with"]
    #[doc = "   unit 0, e.g. glActiveTextureARB(GL_TEXTURE0_ARB); glEnable"]
    #[doc = "   (GL_TEXTURE_2D);"]
    #[doc = " - inEnableLighting - enables or disables OpenGL lighting, e.g."]
    #[doc = "   glEnable(GL_LIGHTING); glEnable(GL_LIGHT0);"]
    #[doc = " - inEnableAlphaTesting - enables or disables the alpha test per pixel, e.g."]
    #[doc = "   glEnable(GL_ALPHA_TEST);"]
    #[doc = " - inEnableAlphaBlending - enables or disables alpha blending per pixel,"]
    #[doc = "   e.g. glEnable(GL_BLEND);"]
    #[doc = " - inEnableDepthTesting - enables per pixel depth testing, as in"]
    #[doc = "   glEnable(GL_DEPTH_TEST);"]
    #[doc = " - inEnableDepthWriting - enables writing back of depth information to the"]
    #[doc = "   depth bufffer, as in glDepthMask(GL_TRUE);"]
    #[doc = ""]
    #[doc = " The purpose of this function is to change OpenGL state while keeping"]
    #[doc = " X-Plane aware of the state changes; this keeps X-Plane from getting"]
    #[doc = " surprised by OGL state changes, and prevents X-Plane and plug-ins from"]
    #[doc = " having to set all state before all draws; XPLMSetGraphicsState internally"]
    #[doc = " skips calls to change state that is already properly enabled."]
    #[doc = ""]
    #[doc = " X-Plane does not have a 'default' OGL state for plug-ins with respect to"]
    #[doc = " the above state vector; plug-ins should totally set OGL state using this"]
    #[doc = " API before drawing.  Use XPLMSetGraphicsState instead of any of the above"]
    #[doc = " OpenGL calls."]
    #[doc = ""]
    #[doc = " WARNING: Any routine that performs drawing (e.g. XPLMDrawString or widget"]
    #[doc = " code) may change X-Plane's state.  Always set state before drawing after"]
    #[doc = " unknown code has executed."]
    #[doc = ""]
    #[doc = " *Deprecation Warnings*: X-Plane's lighting and fog environemnt is"]
    #[doc = "  significantly more complex than the fixed function pipeline can express;"]
    #[doc = "  do not assume that lighting and fog state is a good approximation for 3-d"]
    #[doc = "  drawing.  Prefer to use XPLMInstancing to draw objects.  All calls to"]
    #[doc = "  XPLMSetGraphicsState should have no fog or lighting."]
    #[doc = ""]
    pub fn XPLMSetGraphicsState(
        inEnableFog: ::std::os::raw::c_int,
        inNumberTexUnits: ::std::os::raw::c_int,
        inEnableLighting: ::std::os::raw::c_int,
        inEnableAlphaTesting: ::std::os::raw::c_int,
        inEnableAlphaBlending: ::std::os::raw::c_int,
        inEnableDepthTesting: ::std::os::raw::c_int,
        inEnableDepthWriting: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMBindTexture2d"]
    #[doc = ""]
    #[doc = "  XPLMBindTexture2d changes what texture is bound to the 2d texturing"]
    #[doc = "  target. This routine caches the current 2d texture across all texturing"]
    #[doc = "  units in the sim and plug-ins, preventing extraneous binding.  For"]
    #[doc = "  example, consider several plug-ins running in series; if they all use the"]
    #[doc = "  'general interface' bitmap to do UI, calling this function will skip the"]
    #[doc = "  rebinding of the general interface texture on all but the first plug-in,"]
    #[doc = "  which can provide better frame rate son some graphics cards."]
    #[doc = ""]
    #[doc = " inTextureID is the ID of the texture object to bind; inTextureUnit is a"]
    #[doc = " zero-based texture unit (e.g. 0 for the first one), up to a maximum of 4"]
    #[doc = " units.  (This number may increase in future versions of X-Plane.)"]
    #[doc = ""]
    #[doc = " Use this routine instead of glBindTexture(GL_TEXTURE_2D, ....);"]
    #[doc = ""]
    pub fn XPLMBindTexture2d(
        inTextureNum: ::std::os::raw::c_int,
        inTextureUnit: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMGenerateTextureNumbers"]
    #[doc = ""]
    #[doc = " Use this routine instead of glGenTextures to generate new texture object"]
    #[doc = " IDs. This routine historically ensured that plugins don't use texure IDs"]
    #[doc = " that X-Plane is reserving for its own use."]
    #[doc = ""]
    pub fn XPLMGenerateTextureNumbers(
        outTextureIDs: *mut ::std::os::raw::c_int,
        inCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMWorldToLocal"]
    #[doc = ""]
    #[doc = " This routine translates coordinates from latitude, longitude, and altitude"]
    #[doc = " to local scene coordinates. Latitude and longitude are in decimal degrees,"]
    #[doc = " and altitude is in meters MSL (mean sea level).  The XYZ coordinates are in"]
    #[doc = " meters in the local OpenGL coordinate system."]
    #[doc = ""]
    pub fn XPLMWorldToLocal(
        inLatitude: f64,
        inLongitude: f64,
        inAltitude: f64,
        outX: *mut f64,
        outY: *mut f64,
        outZ: *mut f64,
    );
}
extern "C" {
    #[doc = " XPLMLocalToWorld"]
    #[doc = ""]
    #[doc = " This routine translates a local coordinate triplet back into latitude,"]
    #[doc = " longitude, and altitude.  Latitude and longitude are in decimal degrees,"]
    #[doc = " and altitude is in meters MSL (mean sea level).  The XYZ coordinates are in"]
    #[doc = " meters in the local OpenGL coordinate system."]
    #[doc = ""]
    #[doc = " NOTE: world coordinates are less precise than local coordinates; you should"]
    #[doc = " try to avoid round tripping from local to world and back."]
    #[doc = ""]
    pub fn XPLMLocalToWorld(
        inX: f64,
        inY: f64,
        inZ: f64,
        outLatitude: *mut f64,
        outLongitude: *mut f64,
        outAltitude: *mut f64,
    );
}
extern "C" {
    #[doc = " XPLMDrawTranslucentDarkBox"]
    #[doc = ""]
    #[doc = " This routine draws a translucent dark box, partially obscuring parts of the"]
    #[doc = " screen but making text easy to read.  This is the same graphics primitive"]
    #[doc = " used by X-Plane to show text files and ATC info."]
    #[doc = ""]
    pub fn XPLMDrawTranslucentDarkBox(
        inLeft: ::std::os::raw::c_int,
        inTop: ::std::os::raw::c_int,
        inRight: ::std::os::raw::c_int,
        inBottom: ::std::os::raw::c_int,
    );
}
#[doc = " Mono-spaced font for user interface.  Available in all versions of the SDK."]
pub const xplmFont_Basic: _bindgen_ty_11 = 0;
#[doc = " Proportional UI font."]
pub const xplmFont_Proportional: _bindgen_ty_11 = 18;
#[doc = " XPLMFontID"]
#[doc = ""]
#[doc = " X-Plane features some fixed-character fonts.  Each font may have its own"]
#[doc = " metrics."]
#[doc = ""]
#[doc = " WARNING: Some of these fonts are no longer supported or may have changed"]
#[doc = " geometries. For maximum copmatibility, see the comments below."]
#[doc = ""]
#[doc = " Note: X-Plane 7 supports proportional-spaced fonts.  Since no measuring"]
#[doc = " routine is available yet, the SDK will normally draw using a fixed-width"]
#[doc = " font.  You can use a dataref to enable proportional font drawing on XP7 if"]
#[doc = " you want to."]
#[doc = ""]
pub type _bindgen_ty_11 = ::std::os::raw::c_int;
pub type XPLMFontID = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMDrawString"]
    #[doc = ""]
    #[doc = " This routine draws a NULL termianted string in a given font.  Pass in the"]
    #[doc = " lower left pixel that the character is to be drawn onto.  Also pass the"]
    #[doc = " character and font ID. This function returns the x offset plus the width of"]
    #[doc = " all drawn characters. The color to draw in is specified as a pointer to an"]
    #[doc = " array of three floating point colors, representing RGB intensities from 0.0"]
    #[doc = " to 1.0."]
    #[doc = ""]
    pub fn XPLMDrawString(
        inColorRGB: *mut f32,
        inXOffset: ::std::os::raw::c_int,
        inYOffset: ::std::os::raw::c_int,
        inChar: *mut ::std::os::raw::c_char,
        inWordWrapWidth: *mut ::std::os::raw::c_int,
        inFontID: XPLMFontID,
    );
}
extern "C" {
    #[doc = " XPLMDrawNumber"]
    #[doc = ""]
    #[doc = " This routine draws a number similar to the digit editing fields in"]
    #[doc = " PlaneMaker and data output display in X-Plane.  Pass in a color, a"]
    #[doc = " position, a floating point value, and formatting info.  Specify how many"]
    #[doc = " integer and how many decimal digits to show and whether to show a sign, as"]
    #[doc = " well as a character set. This routine returns the xOffset plus width of the"]
    #[doc = " string drawn."]
    #[doc = ""]
    pub fn XPLMDrawNumber(
        inColorRGB: *mut f32,
        inXOffset: ::std::os::raw::c_int,
        inYOffset: ::std::os::raw::c_int,
        inValue: f64,
        inDigits: ::std::os::raw::c_int,
        inDecimals: ::std::os::raw::c_int,
        inShowSign: ::std::os::raw::c_int,
        inFontID: XPLMFontID,
    );
}
extern "C" {
    #[doc = " XPLMGetFontDimensions"]
    #[doc = ""]
    #[doc = " This routine returns the width and height of a character in a given font."]
    #[doc = " It also tells you if the font only supports numeric digits.  Pass NULL if"]
    #[doc = " you don't need a given field.  Note that for a proportional font the width"]
    #[doc = " will be an arbitrary, hopefully average width."]
    #[doc = ""]
    pub fn XPLMGetFontDimensions(
        inFontID: XPLMFontID,
        outCharWidth: *mut ::std::os::raw::c_int,
        outCharHeight: *mut ::std::os::raw::c_int,
        outDigitsOnly: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMMeasureString"]
    #[doc = ""]
    #[doc = " This routine returns the width in pixels of a string using a given font."]
    #[doc = " The string is passed as a pointer plus length (and does not need to be null"]
    #[doc = " terminated); this is used to allow for measuring substrings. The return"]
    #[doc = " value is floating point; it is possible that future font drawing may allow"]
    #[doc = " for fractional pixels."]
    #[doc = ""]
    pub fn XPLMMeasureString(
        inFontID: XPLMFontID,
        inChar: *const ::std::os::raw::c_char,
        inNumChars: ::std::os::raw::c_int,
    ) -> f32;
}
#[doc = " The Y probe gives you the location of the tallest physical scenery along   *"]
#[doc = " the Y axis going through the queried point."]
pub const xplm_ProbeY: _bindgen_ty_12 = 0;
#[doc = " XPLMProbeType"]
#[doc = ""]
#[doc = " XPLMProbeType defines the type of terrain probe - each probe has a"]
#[doc = " different algorithm. (Only one type of probe is provided right now, but"]
#[doc = " future APIs will expose more flexible or poewrful or useful probes."]
#[doc = ""]
pub type _bindgen_ty_12 = ::std::os::raw::c_int;
pub type XPLMProbeType = ::std::os::raw::c_int;
#[doc = " The probe hit terrain and returned valid values."]
pub const xplm_ProbeHitTerrain: _bindgen_ty_13 = 0;
#[doc = " An error in the API call.  Either the probe struct size is bad, or the     *"]
#[doc = " probe is invalid or the type is mismatched for the specific query call."]
pub const xplm_ProbeError: _bindgen_ty_13 = 1;
#[doc = " The probe call succeeded but there is no terrain under this point (perhaps *"]
#[doc = " it is off the side of the planet?)"]
pub const xplm_ProbeMissed: _bindgen_ty_13 = 2;
#[doc = " XPLMProbeResult"]
#[doc = ""]
#[doc = " Probe results - possible results from a probe query."]
#[doc = ""]
pub type _bindgen_ty_13 = ::std::os::raw::c_int;
pub type XPLMProbeResult = ::std::os::raw::c_int;
#[doc = " XPLMProbeRef"]
#[doc = ""]
#[doc = " An XPLMProbeRef is an opaque handle to a probe, used for querying the"]
#[doc = " terrain."]
#[doc = ""]
pub type XPLMProbeRef = *mut ::std::os::raw::c_void;
#[doc = " XPLMProbeInfo_t"]
#[doc = ""]
#[doc = " XPLMProbeInfo_t contains the results of a probe call. Make sure to set"]
#[doc = " structSize to the size of the struct before using it."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPLMProbeInfo_t {
    #[doc = " Size of structure in bytes - always set this before calling the XPLM."]
    pub structSize: ::std::os::raw::c_int,
    #[doc = " Resulting X location of the terrain point we hit, in local OpenGL          *"]
    #[doc = " coordinates."]
    pub locationX: f32,
    #[doc = " Resulting Y location of the terrain point we hit, in local OpenGL          *"]
    #[doc = " coordinates."]
    pub locationY: f32,
    #[doc = " Resulting Z location of the terrain point we hit, in local OpenGL          *"]
    #[doc = " coordinates."]
    pub locationZ: f32,
    #[doc = " X component of the normal vector to the terrain we found."]
    pub normalX: f32,
    #[doc = " Y component of the normal vector to the terrain we found."]
    pub normalY: f32,
    #[doc = " Z component of the normal vector to the terrain we found."]
    pub normalZ: f32,
    #[doc = " X component of the velocity vector of the terrain we found."]
    pub velocityX: f32,
    #[doc = " Y component of the velocity vector of the terrain we found."]
    pub velocityY: f32,
    #[doc = " Z component of the velocity vector of the terrain we found."]
    pub velocityZ: f32,
    #[doc = " Tells if the surface we hit is water (otherwise it is land)."]
    pub is_wet: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XPLMProbeInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<XPLMProbeInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XPLMProbeInfo_t>(),
        44usize,
        concat!("Size of: ", stringify!(XPLMProbeInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XPLMProbeInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(XPLMProbeInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locationX) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(locationX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locationY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(locationY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locationZ) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(locationZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(normalX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(normalY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalZ) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(normalZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityX) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(velocityX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(velocityY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).velocityZ) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(velocityZ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_wet) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMProbeInfo_t),
            "::",
            stringify!(is_wet)
        )
    );
}
extern "C" {
    #[doc = " XPLMCreateProbe"]
    #[doc = ""]
    #[doc = " Creates a new probe object of a given type and returns."]
    #[doc = ""]
    pub fn XPLMCreateProbe(inProbeType: XPLMProbeType) -> XPLMProbeRef;
}
extern "C" {
    #[doc = " XPLMDestroyProbe"]
    #[doc = ""]
    #[doc = " Deallocates an existing probe object."]
    #[doc = ""]
    pub fn XPLMDestroyProbe(inProbe: XPLMProbeRef);
}
extern "C" {
    #[doc = " XPLMProbeTerrainXYZ"]
    #[doc = ""]
    #[doc = " Probes the terrain. Pass in the XYZ coordinate of the probe point, a probe"]
    #[doc = " object, and an XPLMProbeInfo_t struct that has its structSize member set"]
    #[doc = " properly. Other fields are filled in if we hit terrain, and a probe result"]
    #[doc = " is returned."]
    #[doc = ""]
    pub fn XPLMProbeTerrainXYZ(
        inProbe: XPLMProbeRef,
        inX: f32,
        inY: f32,
        inZ: f32,
        outInfo: *mut XPLMProbeInfo_t,
    ) -> XPLMProbeResult;
}
extern "C" {
    #[doc = " XPLMGetMagneticVariation"]
    #[doc = ""]
    #[doc = " Returns X-Plane's simulated magnetic variation (declination) at the"]
    #[doc = " indication latitude and longitude."]
    #[doc = ""]
    pub fn XPLMGetMagneticVariation(latitude: f64, longitude: f64) -> f32;
}
extern "C" {
    #[doc = " XPLMDegTrueToDegMagnetic"]
    #[doc = ""]
    #[doc = " Converts a heading in degrees relative to true north into a value relative"]
    #[doc = " to magnetic north at the user's current location."]
    #[doc = ""]
    pub fn XPLMDegTrueToDegMagnetic(headingDegreesTrue: f32) -> f32;
}
extern "C" {
    #[doc = " XPLMDegMagneticToDegTrue"]
    #[doc = ""]
    #[doc = " Converts a heading in degrees relative to magnetic north at the user's"]
    #[doc = " current location into a value relative to true north."]
    #[doc = ""]
    pub fn XPLMDegMagneticToDegTrue(headingDegreesMagnetic: f32) -> f32;
}
#[doc = " XPLMObjectRef"]
#[doc = ""]
#[doc = " An XPLMObjectRef is a opaque handle to an .obj file that has been loaded"]
#[doc = " into memory."]
#[doc = ""]
pub type XPLMObjectRef = *mut ::std::os::raw::c_void;
#[doc = " XPLMDrawInfo_t"]
#[doc = ""]
#[doc = " The XPLMDrawInfo_t structure contains positioning info for one object that"]
#[doc = " is to be drawn. Be sure to set structSize to the size of the structure for"]
#[doc = " future expansion."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPLMDrawInfo_t {
    #[doc = " Set this to the size of this structure!"]
    pub structSize: ::std::os::raw::c_int,
    #[doc = " X location of the object in local coordinates."]
    pub x: f32,
    #[doc = " Y location of the object in local coordinates."]
    pub y: f32,
    #[doc = " Z location of the object in local coordinates."]
    pub z: f32,
    #[doc = " Pitch in degres to rotate the object, positive is up."]
    pub pitch: f32,
    #[doc = " Heading in local coordinates to rotate the object, clockwise."]
    pub heading: f32,
    #[doc = " Roll to rotate the object."]
    pub roll: f32,
}
#[test]
fn bindgen_test_layout_XPLMDrawInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<XPLMDrawInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XPLMDrawInfo_t>(),
        28usize,
        concat!("Size of: ", stringify!(XPLMDrawInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XPLMDrawInfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(XPLMDrawInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).heading) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(heading)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roll) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMDrawInfo_t),
            "::",
            stringify!(roll)
        )
    );
}
#[doc = " XPLMObjectLoaded_f"]
#[doc = ""]
#[doc = " You provide this callback when loading an object asynchronously; it will be"]
#[doc = " called once the object is loaded. Your refcon is passed back. The object"]
#[doc = " ref passed in is the newly loaded object (ready for use) or NULL if an"]
#[doc = " error occured."]
#[doc = ""]
#[doc = " If your plugin is disabled, this callback will be delivered as soon as the"]
#[doc = " plugin is re-enabled. If your plugin is unloaded before this callback is"]
#[doc = " ever called, the SDK will release the object handle for you."]
#[doc = ""]
pub type XPLMObjectLoaded_f = ::std::option::Option<
    unsafe extern "C" fn(inObject: XPLMObjectRef, inRefcon: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " XPLMLoadObject"]
    #[doc = ""]
    #[doc = " This routine loads an OBJ file and returns a handle to it. If X-Plane has"]
    #[doc = " already loaded the object, the handle to the existing object is returned."]
    #[doc = " Do not assume you will get the same handle back twice, but do make sure to"]
    #[doc = " call unload once for every load to avoid \"leaking\" objects. The object will"]
    #[doc = " be purged from memory when no plugins and no scenery are using it."]
    #[doc = ""]
    #[doc = " The path for the object must be relative to the X-System base folder. If"]
    #[doc = " the path is in the root of the X-System folder you may need to prepend ./"]
    #[doc = " to it; loading objects in the root of the X-System folder is STRONGLY"]
    #[doc = " discouraged - your plugin should not dump art resources in the root folder!"]
    #[doc = ""]
    #[doc = " XPLMLoadObject will return NULL if the object cannot be loaded (either"]
    #[doc = " because it is not found or the file is misformatted). This routine will"]
    #[doc = " load any object that can be used in the X-Plane scenery system."]
    #[doc = ""]
    #[doc = " It is important that the datarefs an object uses for animation already be"]
    #[doc = " loaded before you load the object. For this reason it may be necessary to"]
    #[doc = " defer object loading until the sim has fully started."]
    #[doc = ""]
    pub fn XPLMLoadObject(inPath: *const ::std::os::raw::c_char) -> XPLMObjectRef;
}
extern "C" {
    #[doc = " XPLMLoadObjectAsync"]
    #[doc = ""]
    #[doc = " This routine loads an object asynchronously; control is returned to you"]
    #[doc = " immediately while X-Plane loads the object. The sim will not stop flying"]
    #[doc = " while the object loads. For large objects, it may be several seconds before"]
    #[doc = " the load finishes."]
    #[doc = ""]
    #[doc = " You provide a callback function that is called once the load has completed."]
    #[doc = " Note that if the object cannot be loaded, you will not find out until the"]
    #[doc = " callback function is called with a NULL object handle."]
    #[doc = ""]
    #[doc = " There is no way to cancel an asynchronous object load; you must wait for"]
    #[doc = " the load to complete and then release the object if it is no longer"]
    #[doc = " desired."]
    #[doc = ""]
    pub fn XPLMLoadObjectAsync(
        inPath: *const ::std::os::raw::c_char,
        inCallback: XPLMObjectLoaded_f,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMUnloadObject"]
    #[doc = ""]
    #[doc = " This routine marks an object as no longer being used by your plugin."]
    #[doc = " Objects are reference counted: once no plugins are using an object, it is"]
    #[doc = " purged from memory. Make sure to call XPLMUnloadObject once for each"]
    #[doc = " successful call to XPLMLoadObject."]
    #[doc = ""]
    pub fn XPLMUnloadObject(inObject: XPLMObjectRef);
}
#[doc = " XPLMLibraryEnumerator_f"]
#[doc = ""]
#[doc = " An XPLMLibraryEnumerator_f is a callback you provide that is called once"]
#[doc = " for each library element that is located. The returned paths will be"]
#[doc = " relative to the X-System folder."]
#[doc = ""]
pub type XPLMLibraryEnumerator_f = ::std::option::Option<
    unsafe extern "C" fn(
        inFilePath: *const ::std::os::raw::c_char,
        inRef: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " XPLMLookupObjects"]
    #[doc = ""]
    #[doc = " This routine looks up a virtual path in the library system and returns all"]
    #[doc = " matching elements. You provide a callback - one virtual path may match many"]
    #[doc = " objects in the library. XPLMLookupObjects returns the number of objects"]
    #[doc = " found."]
    #[doc = ""]
    #[doc = " The latitude and longitude parameters specify the location the object will"]
    #[doc = " be used. The library system allows for scenery packages to only provide"]
    #[doc = " objects to certain local locations. Only objects that are allowed at the"]
    #[doc = " latitude/longitude you provide will be returned."]
    #[doc = ""]
    pub fn XPLMLookupObjects(
        inPath: *const ::std::os::raw::c_char,
        inLatitude: f32,
        inLongitude: f32,
        enumerator: XPLMLibraryEnumerator_f,
        ref_: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " XPLMInstanceRef"]
#[doc = ""]
#[doc = " An opaque handle to an instance."]
#[doc = ""]
pub type XPLMInstanceRef = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " XPLMCreateInstance"]
    #[doc = ""]
    #[doc = " XPLMCreateInstance creates a new instance, managed by your plug-in, and"]
    #[doc = " returns a handle to the instance. A few important requirements:"]
    #[doc = ""]
    #[doc = " * The object passed in must be fully loaded and returned from the XPLM"]
    #[doc = "   before you can create your instance; you cannot pass a null obj ref, nor"]
    #[doc = "   can you change the ref later."]
    #[doc = ""]
    #[doc = " * If you use any custom datarefs in your object, they must be registered"]
    #[doc = "   before the object is loaded. This is true even if their data will be"]
    #[doc = "   provided via the instance dataref list."]
    #[doc = ""]
    #[doc = " * The instance dataref array must be a valid ptr to an array of at least"]
    #[doc = "   one item that is null terminated.  That is, if you do not want any"]
    #[doc = "   datarefs, you must passa ptr to an array with a null item.  You cannot"]
    #[doc = "   pass null for this."]
    #[doc = ""]
    pub fn XPLMCreateInstance(
        obj: XPLMObjectRef,
        datarefs: *mut *const ::std::os::raw::c_char,
    ) -> XPLMInstanceRef;
}
extern "C" {
    #[doc = " XPLMDestroyInstance"]
    #[doc = ""]
    #[doc = " XPLMDestroyInstance destroys and deallocates your instance; once called,"]
    #[doc = " you are still responsible for releasing the OBJ ref."]
    #[doc = ""]
    #[doc = " Tip: you can release your OBJ ref after you call XPLMCreateInstance as long"]
    #[doc = " as you never use it again; the instance will maintain its own reference to"]
    #[doc = " the OBJ and the object OBJ be deallocated when the instance is destroyed."]
    #[doc = ""]
    pub fn XPLMDestroyInstance(instance: XPLMInstanceRef);
}
extern "C" {
    #[doc = " XPLMInstanceSetPosition"]
    #[doc = ""]
    #[doc = " Updates both the position of the instance and all datarefs you registered"]
    #[doc = " for it.  Call this from a flight loop callback or UI callback."]
    #[doc = ""]
    #[doc = " __DO NOT__ call XPLMInstanceSetPosition from a drawing callback; the whole"]
    #[doc = " point of instancing is that you do not need any drawing callbacks. Setting"]
    #[doc = " instance data from a drawing callback may have undefined consequences, and"]
    #[doc = " the drawing callback hurts FPS unnecessarily."]
    #[doc = ""]
    #[doc = " The memory pointed to by the data pointer must be large enough to hold one"]
    #[doc = " float for every data ref you have registered, and must contain valid"]
    #[doc = " floating point data."]
    #[doc = ""]
    #[doc = " BUG: before X-Plane 11.50, if you have no dataref registered, you must"]
    #[doc = " still pass a valid pointer for data and not null."]
    #[doc = ""]
    pub fn XPLMInstanceSetPosition(
        instance: XPLMInstanceRef,
        new_position: *const XPLMDrawInfo_t,
        data: *const f32,
    );
}
#[doc = " XPLMMapLayerID"]
#[doc = ""]
#[doc = " This is an opaque handle for a plugin-created map layer. Pass it to the map"]
#[doc = " drawing APIs from an appropriate callback to draw in the layer you created."]
#[doc = ""]
pub type XPLMMapLayerID = *mut ::std::os::raw::c_void;
#[doc = " XPLMMapProjectionID"]
#[doc = ""]
#[doc = " This is an opaque handle for a map projection. Pass it to the projection"]
#[doc = " APIs to translate between map coordinates and latitude/longitudes."]
#[doc = ""]
pub type XPLMMapProjectionID = *mut ::std::os::raw::c_void;
pub const xplm_MapStyle_VFR_Sectional: _bindgen_ty_14 = 0;
pub const xplm_MapStyle_IFR_LowEnroute: _bindgen_ty_14 = 1;
pub const xplm_MapStyle_IFR_HighEnroute: _bindgen_ty_14 = 2;
#[doc = " XPLMMapStyle"]
#[doc = ""]
#[doc = " Indicates the visual style being drawn by the map. In X-Plane, the user can"]
#[doc = " choose between a number of map types, and different map types may have use"]
#[doc = " a different visual representation for the same elements (for instance, the"]
#[doc = " visual style of the terrain layer changes drastically between the VFR and"]
#[doc = " IFR layers), or certain layers may be disabled entirely in some map types"]
#[doc = " (e.g., localizers are only visible in the IFR low-enroute style)."]
#[doc = ""]
pub type _bindgen_ty_14 = ::std::os::raw::c_int;
pub type XPLMMapStyle = ::std::os::raw::c_int;
#[doc = " XPLMMapDrawingCallback_f"]
#[doc = ""]
#[doc = " This is the OpenGL map drawing callback for plugin-created map layers. You"]
#[doc = " can perform arbitrary OpenGL drawing from this callback, with one"]
#[doc = " exception: changes to the Z-buffer are not permitted, and will result in"]
#[doc = " map drawing errors."]
#[doc = ""]
#[doc = " All drawing done from within this callback appears beneath all built-in"]
#[doc = " X-Plane icons and labels, but above the built-in \"fill\" layers (layers"]
#[doc = " providing major details, like terrain and water). Note, however, that the"]
#[doc = " relative ordering between the drawing callbacks of different plugins is not"]
#[doc = " guaranteed."]
#[doc = ""]
pub type XPLMMapDrawingCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        inLayer: XPLMMapLayerID,
        inMapBoundsLeftTopRightBottom: *const f32,
        zoomRatio: f32,
        mapUnitsPerUserInterfaceUnit: f32,
        mapStyle: XPLMMapStyle,
        projection: XPLMMapProjectionID,
        inRefcon: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " XPLMMapIconDrawingCallback_f"]
#[doc = ""]
#[doc = " This is the icon drawing callback that enables plugin-created map layers to"]
#[doc = " draw icons using X-Plane's built-in icon drawing functionality. You can"]
#[doc = " request an arbitrary number of PNG icons to be drawn via"]
#[doc = " XPLMDrawMapIconFromSheet() from within this callback, but you may not"]
#[doc = " perform any OpenGL drawing here."]
#[doc = ""]
#[doc = " Icons enqueued by this function will appear above all OpenGL drawing"]
#[doc = " (performed by your optional XPLMMapDrawingCallback_f), and above all"]
#[doc = " built-in X-Plane map icons of the same layer type (\"fill\" or \"markings,\" as"]
#[doc = " determined by the XPLMMapLayerType in your XPLMCreateMapLayer_t). Note,"]
#[doc = " however, that the relative ordering between the drawing callbacks of"]
#[doc = " different plugins is not guaranteed."]
#[doc = ""]
pub type XPLMMapIconDrawingCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        inLayer: XPLMMapLayerID,
        inMapBoundsLeftTopRightBottom: *const f32,
        zoomRatio: f32,
        mapUnitsPerUserInterfaceUnit: f32,
        mapStyle: XPLMMapStyle,
        projection: XPLMMapProjectionID,
        inRefcon: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " XPLMMapLabelDrawingCallback_f"]
#[doc = ""]
#[doc = " This is the label drawing callback that enables plugin-created map layers"]
#[doc = " to draw text labels using X-Plane's built-in labeling functionality. You"]
#[doc = " can request an arbitrary number of text labels to be drawn via"]
#[doc = " XPLMDrawMapLabel() from within this callback, but you may not perform any"]
#[doc = " OpenGL drawing here."]
#[doc = ""]
#[doc = " Labels enqueued by this function will appear above all OpenGL drawing"]
#[doc = " (performed by your optional XPLMMapDrawingCallback_f), and above all"]
#[doc = " built-in map icons and labels of the same layer type (\"fill\" or \"markings,\""]
#[doc = " as determined by the XPLMMapLayerType in your XPLMCreateMapLayer_t). Note,"]
#[doc = " however, that the relative ordering between the drawing callbacks of"]
#[doc = " different plugins is not guaranteed."]
#[doc = ""]
pub type XPLMMapLabelDrawingCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        inLayer: XPLMMapLayerID,
        inMapBoundsLeftTopRightBottom: *const f32,
        zoomRatio: f32,
        mapUnitsPerUserInterfaceUnit: f32,
        mapStyle: XPLMMapStyle,
        projection: XPLMMapProjectionID,
        inRefcon: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " XPLMMapPrepareCacheCallback_f"]
#[doc = ""]
#[doc = " A callback used to allow you to cache whatever information your layer needs"]
#[doc = " to draw in the current map area."]
#[doc = ""]
#[doc = " This is called each time the map's total bounds change. This is typically"]
#[doc = " triggered by new DSFs being loaded, such that X-Plane discards old,"]
#[doc = " now-distant DSFs and pulls in new ones. At that point, the available bounds"]
#[doc = " of the map also change to match the new DSF area."]
#[doc = ""]
#[doc = " By caching just the information you need to draw in this area, your future"]
#[doc = " draw calls can be made faster, since you'll be able to simply \"splat\" your"]
#[doc = " precomputed information each frame."]
#[doc = ""]
#[doc = " We guarantee that the map projection will not change between successive"]
#[doc = " prepare cache calls, nor will any draw call give you bounds outside these"]
#[doc = " total map bounds. So, if you cache the projected map coordinates of all the"]
#[doc = " items you might want to draw in the total map area, you can be guaranteed"]
#[doc = " that no draw call will be asked to do any new work."]
#[doc = ""]
pub type XPLMMapPrepareCacheCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        inLayer: XPLMMapLayerID,
        inTotalMapBoundsLeftTopRightBottom: *const f32,
        projection: XPLMMapProjectionID,
        inRefcon: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " XPLMMapWillBeDeletedCallback_f"]
#[doc = ""]
#[doc = " Called just before your map layer gets deleted. Because SDK-created map"]
#[doc = " layers have the same lifetime as the X-Plane map that contains them, if the"]
#[doc = " map gets unloaded from memory, your layer will too."]
#[doc = ""]
pub type XPLMMapWillBeDeletedCallback_f = ::std::option::Option<
    unsafe extern "C" fn(inLayer: XPLMMapLayerID, inRefcon: *mut ::std::os::raw::c_void),
>;
#[doc = " A layer that draws \"fill\" graphics, like weather patterns, terrain, etc.   *"]
#[doc = " Fill layers frequently cover a large portion of the visible map area."]
pub const xplm_MapLayer_Fill: _bindgen_ty_15 = 0;
#[doc = " A layer that provides markings for particular map features, like NAVAIDs,  *"]
#[doc = " airports, etc. Even dense markings layers cover a small portion of the     *"]
#[doc = " total map area."]
pub const xplm_MapLayer_Markings: _bindgen_ty_15 = 1;
#[doc = " XPLMMapLayerType"]
#[doc = ""]
#[doc = " Indicates the type of map layer you are creating. Fill layers will always"]
#[doc = " be drawn beneath markings layers."]
#[doc = ""]
pub type _bindgen_ty_15 = ::std::os::raw::c_int;
pub type XPLMMapLayerType = ::std::os::raw::c_int;
#[doc = " XPLMCreateMapLayer_t"]
#[doc = ""]
#[doc = " This structure defines all of the parameters used to create a map layer"]
#[doc = " using XPLMCreateMapLayer. The structure will be expanded in future SDK APIs"]
#[doc = " to include more features.  Always set the structSize member to the size of"]
#[doc = " your struct in bytes!"]
#[doc = ""]
#[doc = " Each layer must be associated with exactly one map instance in X-Plane."]
#[doc = " That map, and that map alone, will call your callbacks. Likewise, when that"]
#[doc = " map is deleted, your layer will be as well."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPLMCreateMapLayer_t {
    #[doc = " Used to inform XPLMCreateMapLayer() of the SDK version you compiled        *"]
    #[doc = " against; should always be set to sizeof(XPLMCreateMapLayer_t)"]
    pub structSize: ::std::os::raw::c_int,
    #[doc = " Globally unique string identifying the map you want this layer to appear   *"]
    #[doc = " in. As of XPLM300, this is limited to one of XPLM_MAP_USER_INTERFACE or    *"]
    #[doc = " XPLM_MAP_IOS"]
    pub mapToCreateLayerIn: *const ::std::os::raw::c_char,
    #[doc = " The type of layer you are creating, used to determine draw order (all      *"]
    #[doc = " plugin-created markings layers are drawn above all plugin-created fill     *"]
    #[doc = " layers)"]
    pub layerType: XPLMMapLayerType,
    #[doc = " Optional callback to inform you this layer is being deleted (due to its    *"]
    #[doc = " owning map being destroyed)"]
    pub willBeDeletedCallback: XPLMMapWillBeDeletedCallback_f,
    #[doc = " Optional callback you want to use to prepare your draw cache when the map  *"]
    #[doc = " bounds change (set to NULL if you don't want this callback)"]
    pub prepCacheCallback: XPLMMapPrepareCacheCallback_f,
    #[doc = " Optional callback you want to use for arbitrary OpenGL drawing, which goes *"]
    #[doc = " beneath all icons in the map's layering system (set to NULL if you don't   *"]
    #[doc = " want this callback)"]
    pub drawCallback: XPLMMapDrawingCallback_f,
    #[doc = " Optional callback you want to use for drawing icons, which go above all    *"]
    #[doc = " built-in X-Plane icons (except the aircraft) in the map's layering system  *"]
    #[doc = " (set to NULL if you don't want this callback)"]
    pub iconCallback: XPLMMapIconDrawingCallback_f,
    #[doc = " Optional callback you want to use for drawing map labels, which go above   *"]
    #[doc = " all built-in X-Plane icons and labels (except those of aircraft) in the    *"]
    #[doc = " map's layering system (set to NULL if you don't want this callback)"]
    pub labelCallback: XPLMMapLabelDrawingCallback_f,
    #[doc = " True if you want a checkbox to be created in the map UI to toggle this     *"]
    #[doc = " layer on and off; false if the layer should simply always be enabled"]
    pub showUiToggle: ::std::os::raw::c_int,
    #[doc = " Short label to use for this layer in the user interface"]
    pub layerName: *const ::std::os::raw::c_char,
    #[doc = " A reference to arbitrary data that will be passed to your callbacks"]
    pub refcon: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_XPLMCreateMapLayer_t() {
    const UNINIT: ::std::mem::MaybeUninit<XPLMCreateMapLayer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XPLMCreateMapLayer_t>(),
        88usize,
        concat!("Size of: ", stringify!(XPLMCreateMapLayer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XPLMCreateMapLayer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(XPLMCreateMapLayer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapToCreateLayerIn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(mapToCreateLayerIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layerType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(layerType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).willBeDeletedCallback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(willBeDeletedCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepCacheCallback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(prepCacheCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drawCallback) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(drawCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iconCallback) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(iconCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).labelCallback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(labelCallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).showUiToggle) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(showUiToggle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layerName) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(layerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcon) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateMapLayer_t),
            "::",
            stringify!(refcon)
        )
    );
}
extern "C" {
    #[doc = " XPLMCreateMapLayer"]
    #[doc = ""]
    #[doc = " This routine creates a new map layer. You pass in an XPLMCreateMapLayer_t"]
    #[doc = " structure with all of the fields set in.  You must set the structSize of"]
    #[doc = " the structure to the size of the actual structure you used."]
    #[doc = ""]
    #[doc = " Returns NULL if the layer creation failed. This happens most frequently"]
    #[doc = " because the map you specified in your"]
    #[doc = " XPLMCreateMapLayer_t::mapToCreateLayerIn field doesn't exist (that is, if"]
    #[doc = " XPLMMapExists() returns 0 for the specified map). You can use"]
    #[doc = " XPLMRegisterMapCreationHook() to get a notification each time a new map is"]
    #[doc = " opened in X-Plane, at which time you can create layers in it."]
    #[doc = ""]
    pub fn XPLMCreateMapLayer(inParams: *mut XPLMCreateMapLayer_t) -> XPLMMapLayerID;
}
extern "C" {
    #[doc = " XPLMDestroyMapLayer"]
    #[doc = ""]
    #[doc = " Destroys a map layer you created (calling your"]
    #[doc = " XPLMMapWillBeDeletedCallback_f if applicable). Returns true if a deletion"]
    #[doc = " took place."]
    #[doc = ""]
    pub fn XPLMDestroyMapLayer(inLayer: XPLMMapLayerID) -> ::std::os::raw::c_int;
}
#[doc = " XPLMMapCreatedCallback_f"]
#[doc = ""]
#[doc = " A callback to notify your plugin that a new map has been created in"]
#[doc = " X-Plane. This is the best time to add a custom map layer using"]
#[doc = " XPLMCreateMapLayer()."]
#[doc = ""]
#[doc = " No OpenGL drawing is permitted within this callback."]
#[doc = ""]
pub type XPLMMapCreatedCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        mapIdentifier: *const ::std::os::raw::c_char,
        refcon: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " XPLMRegisterMapCreationHook"]
    #[doc = ""]
    #[doc = " Registers your callback to receive a notification each time a new map is"]
    #[doc = " constructed in X-Plane. This callback is the best time to add your custom"]
    #[doc = " map layer using XPLMCreateMapLayer()."]
    #[doc = ""]
    #[doc = " Note that you will not be notified about any maps that already exist---you"]
    #[doc = " can use XPLMMapExists() to check for maps that were created previously."]
    #[doc = ""]
    pub fn XPLMRegisterMapCreationHook(
        callback: XPLMMapCreatedCallback_f,
        refcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMMapExists"]
    #[doc = ""]
    #[doc = " Returns 1 if the map with the specified identifier already exists in"]
    #[doc = " X-Plane. In that case, you can safely call XPLMCreateMapLayer() specifying"]
    #[doc = " that your layer should be added to that map."]
    #[doc = ""]
    pub fn XPLMMapExists(mapIdentifier: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[doc = " Orient such that a 0 degree rotation matches the map's north"]
pub const xplm_MapOrientation_Map: _bindgen_ty_16 = 0;
#[doc = " Orient such that a 0 degree rotation is \"up\" relative to the user interface"]
pub const xplm_MapOrientation_UI: _bindgen_ty_16 = 1;
#[doc = " XPLMMapOrientation"]
#[doc = ""]
#[doc = " Indicates whether a map element should be match its rotation to the map"]
#[doc = " itself, or to the user interface. For instance, the map itself may be"]
#[doc = " rotated such that \"up\" matches the user's aircraft, but you may want to"]
#[doc = " draw a text label such that it is always rotated zero degrees relative to"]
#[doc = " the user's perspective. In that case, you would have it draw with UI"]
#[doc = " orientation."]
#[doc = ""]
pub type _bindgen_ty_16 = ::std::os::raw::c_int;
pub type XPLMMapOrientation = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMDrawMapIconFromSheet"]
    #[doc = ""]
    #[doc = " Enables plugin-created map layers to draw PNG icons using X-Plane's"]
    #[doc = " built-in icon drawing functionality. Only valid from within an"]
    #[doc = " XPLMIconDrawingCallback_t (but you can request an arbitrary number of icons"]
    #[doc = " to be drawn from within your callback)."]
    #[doc = ""]
    #[doc = " X-Plane will automatically manage the memory for your texture so that it"]
    #[doc = " only has to be loaded from disk once as long as you continue drawing it"]
    #[doc = " per-frame. (When you stop drawing it, the memory may purged in a \"garbage"]
    #[doc = " collection\" pass, require a load from disk in the future.)"]
    #[doc = ""]
    #[doc = " Instead of having X-Plane draw a full PNG, this method allows you to use UV"]
    #[doc = " coordinates to request a portion of the image to be drawn. This allows you"]
    #[doc = " to use a single texture load (of an icon sheet, for example) to draw many"]
    #[doc = " icons. Doing so is much more efficient than drawing a dozen different small"]
    #[doc = " PNGs."]
    #[doc = ""]
    #[doc = " The UV coordinates used here treat the texture you load as being comprised"]
    #[doc = " of a number of identically sized \"cells.\" You specify the width and height"]
    #[doc = " in cells (ds and dt, respectively), as well as the coordinates within the"]
    #[doc = " cell grid for the sub-image you'd like to draw."]
    #[doc = ""]
    #[doc = " Note that you can use different ds and dt values in subsequent calls with"]
    #[doc = " the same texture sheet. This enables you to use icons of different sizes in"]
    #[doc = " the same sheet if you arrange them properly in the PNG."]
    #[doc = ""]
    #[doc = " This function is only valid from within an XPLMIconDrawingCallback_t (but"]
    #[doc = " you can request an arbitrary number of icons to be drawn from within your"]
    #[doc = " callback)."]
    #[doc = ""]
    pub fn XPLMDrawMapIconFromSheet(
        layer: XPLMMapLayerID,
        inPngPath: *const ::std::os::raw::c_char,
        s: ::std::os::raw::c_int,
        t: ::std::os::raw::c_int,
        ds: ::std::os::raw::c_int,
        dt: ::std::os::raw::c_int,
        mapX: f32,
        mapY: f32,
        orientation: XPLMMapOrientation,
        rotationDegrees: f32,
        mapWidth: f32,
    );
}
extern "C" {
    #[doc = " XPLMDrawMapLabel"]
    #[doc = ""]
    #[doc = " Enables plugin-created map layers to draw text labels using X-Plane's"]
    #[doc = " built-in labeling functionality. Only valid from within an"]
    #[doc = " XPLMMapLabelDrawingCallback_f (but you can request an arbitrary number of"]
    #[doc = " text labels to be drawn from within your callback)."]
    #[doc = ""]
    pub fn XPLMDrawMapLabel(
        layer: XPLMMapLayerID,
        inText: *const ::std::os::raw::c_char,
        mapX: f32,
        mapY: f32,
        orientation: XPLMMapOrientation,
        rotationDegrees: f32,
    );
}
extern "C" {
    #[doc = " XPLMMapProject"]
    #[doc = ""]
    #[doc = " Projects a latitude/longitude into map coordinates. This is the inverse of"]
    #[doc = " XPLMMapUnproject()."]
    #[doc = ""]
    #[doc = " Only valid from within a map layer callback (one of"]
    #[doc = " XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,"]
    #[doc = " XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)"]
    #[doc = ""]
    pub fn XPLMMapProject(
        projection: XPLMMapProjectionID,
        latitude: f64,
        longitude: f64,
        outX: *mut f32,
        outY: *mut f32,
    );
}
extern "C" {
    #[doc = " XPLMMapUnproject"]
    #[doc = ""]
    #[doc = " Transforms map coordinates back into a latitude and longitude. This is the"]
    #[doc = " inverse of XPLMMapProject()."]
    #[doc = ""]
    #[doc = " Only valid from within a map layer callback (one of"]
    #[doc = " XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,"]
    #[doc = " XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)"]
    #[doc = ""]
    pub fn XPLMMapUnproject(
        projection: XPLMMapProjectionID,
        mapX: f32,
        mapY: f32,
        outLatitude: *mut f64,
        outLongitude: *mut f64,
    );
}
extern "C" {
    #[doc = " XPLMMapScaleMeter"]
    #[doc = ""]
    #[doc = " Returns the number of map units that correspond to a distance of one meter"]
    #[doc = " at a given set of map coordinates."]
    #[doc = ""]
    #[doc = " Only valid from within a map layer callback (one of"]
    #[doc = " XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,"]
    #[doc = " XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)"]
    #[doc = ""]
    pub fn XPLMMapScaleMeter(projection: XPLMMapProjectionID, mapX: f32, mapY: f32) -> f32;
}
extern "C" {
    #[doc = " XPLMMapGetNorthHeading"]
    #[doc = ""]
    #[doc = " Returns the heading (in degrees clockwise from \"up\") that corresponds to"]
    #[doc = " north at a given point on the map. In other words, if your runway has a"]
    #[doc = " true heading of 360, you would use \"north\" as the Cartesian angle at which"]
    #[doc = " to draw the runway on the map. (You would add the result of"]
    #[doc = " XPLMMapGetNorthHeading() to your true heading to get the map angle.)"]
    #[doc = ""]
    #[doc = " This is necessary becuase X-Plane's map can be rotated to match your"]
    #[doc = " aircraft's orientation; north is not always \"up.\""]
    #[doc = ""]
    #[doc = " Only valid from within a map layer callback (one of"]
    #[doc = " XPLMMapPrepareCacheCallback_f, XPLMMapDrawingCallback_f,"]
    #[doc = " XPLMMapIconDrawingCallback_f, or XPLMMapLabelDrawingCallback_f.)"]
    #[doc = ""]
    pub fn XPLMMapGetNorthHeading(projection: XPLMMapProjectionID, mapX: f32, mapY: f32) -> f32;
}
#[doc = " A situation (.sit) file, which starts off a flight in a given              *"]
#[doc = " configuration."]
pub const xplm_DataFile_Situation: _bindgen_ty_17 = 1;
#[doc = " A situation movie (.smo) file, which replays a past flight."]
pub const xplm_DataFile_ReplayMovie: _bindgen_ty_17 = 2;
#[doc = " XPLMDataFileType"]
#[doc = ""]
#[doc = " These enums define types of data files you can load or unload using the"]
#[doc = " SDK."]
#[doc = ""]
pub type _bindgen_ty_17 = ::std::os::raw::c_int;
pub type XPLMDataFileType = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMGetSystemPath"]
    #[doc = ""]
    #[doc = " This function returns the full path to the X-System folder. Note that this"]
    #[doc = " is a directory path, so it ends in a trailing : or /."]
    #[doc = ""]
    #[doc = " The buffer you pass should be at least 512 characters long.  The path is"]
    #[doc = " returned using the current native or OS path conventions."]
    #[doc = ""]
    pub fn XPLMGetSystemPath(outSystemPath: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " XPLMGetPrefsPath"]
    #[doc = ""]
    #[doc = " This routine returns a full path to a file that is within X-Plane's"]
    #[doc = " preferences directory. (You should remove the file name back to the last"]
    #[doc = " directory separator to get the preferences directory using"]
    #[doc = " XPLMExtractFileAndPath.)"]
    #[doc = ""]
    #[doc = " The buffer you pass should be at least 512 characters long.  The path is"]
    #[doc = " returned using the current native or OS path conventions."]
    #[doc = ""]
    pub fn XPLMGetPrefsPath(outPrefsPath: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " XPLMGetDirectorySeparator"]
    #[doc = ""]
    #[doc = " This routine returns a string with one char and a null terminator that is"]
    #[doc = " the directory separator for the current platform. This allows you to write"]
    #[doc = " code that concatinates directory paths without having to #ifdef for"]
    #[doc = " platform. The character returned will reflect the current file path mode."]
    #[doc = ""]
    pub fn XPLMGetDirectorySeparator() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " XPLMExtractFileAndPath"]
    #[doc = ""]
    #[doc = " Given a full path to a file, this routine separates the path from the file."]
    #[doc = " If the path is a partial directory (e.g. ends in : or \\) the trailing"]
    #[doc = " directory separator is removed. This routine works in-place; a pointer to"]
    #[doc = " the file part of the buffer is returned; the original buffer still starts"]
    #[doc = " with the path and is null terminated with no trailing separator."]
    #[doc = ""]
    pub fn XPLMExtractFileAndPath(
        inFullPath: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " XPLMGetDirectoryContents"]
    #[doc = ""]
    #[doc = " This routine returns a list of files in a directory (specified by a full"]
    #[doc = " path, no trailing : or \\). The output is returned as a list of NULL"]
    #[doc = " terminated strings. An index array (if specified) is filled with pointers"]
    #[doc = " into the strings. The last file is indicated by a zero-length string (and"]
    #[doc = " NULL in the indices). This routine will return 1 if you had capacity for"]
    #[doc = " all files or 0 if you did not. You can also skip a given number of files."]
    #[doc = ""]
    #[doc = "  * inDirectoryPath - a null terminated C string containing the full path to"]
    #[doc = "    the directory with no trailing directory char."]
    #[doc = ""]
    #[doc = "  * inFirstReturn - the zero-based index of the first file in the directory"]
    #[doc = "    to return. (Usually zero to fetch all in one pass.)"]
    #[doc = ""]
    #[doc = "  * outFileNames - a buffer to receive a series of sequential null"]
    #[doc = "    terminated C-string file names. A zero-length C string will be appended"]
    #[doc = "    to the very end."]
    #[doc = ""]
    #[doc = "  * inFileNameBufSize - the size of the file name buffer in bytes."]
    #[doc = ""]
    #[doc = "  * outIndices - a pointer to an array of character pointers that will"]
    #[doc = "    become an index into the directory. The last file will be followed by a"]
    #[doc = "    NULL value. Pass NULL if you do not want indexing information."]
    #[doc = ""]
    #[doc = "  * inIndexCount - the max size of the index in entries."]
    #[doc = ""]
    #[doc = "  * outTotalFiles - if not NULL, this is filled in with the number of files"]
    #[doc = "    in the directory."]
    #[doc = ""]
    #[doc = "  * outReturnedFiles - if not NULL, the number of files returned by this"]
    #[doc = "    iteration."]
    #[doc = ""]
    #[doc = " Return value: 1 if all info could be returned, 0 if there was a buffer"]
    #[doc = " overrun."]
    #[doc = ""]
    #[doc = " WARNING: Before X-Plane 7 this routine did not properly iterate through"]
    #[doc = " directories. If X-Plane"]
    #[doc = " 6 compatibility is needed, use your own code to iterate directories."]
    #[doc = ""]
    pub fn XPLMGetDirectoryContents(
        inDirectoryPath: *const ::std::os::raw::c_char,
        inFirstReturn: ::std::os::raw::c_int,
        outFileNames: *mut ::std::os::raw::c_char,
        inFileNameBufSize: ::std::os::raw::c_int,
        outIndices: *mut *mut ::std::os::raw::c_char,
        inIndexCount: ::std::os::raw::c_int,
        outTotalFiles: *mut ::std::os::raw::c_int,
        outReturnedFiles: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMLoadDataFile"]
    #[doc = ""]
    #[doc = " Loads a data file of a given type. Paths must be relative to the X-System"]
    #[doc = " folder. To clear the replay, pass a NULL file name (this is only valid with"]
    #[doc = " replay movies, not sit files)."]
    #[doc = ""]
    pub fn XPLMLoadDataFile(
        inFileType: XPLMDataFileType,
        inFilePath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSaveDataFile"]
    #[doc = ""]
    #[doc = " Saves the current situation or replay; paths are relative to the X-System"]
    #[doc = " folder."]
    #[doc = ""]
    pub fn XPLMSaveDataFile(
        inFileType: XPLMDataFileType,
        inFilePath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const xplm_Host_Unknown: _bindgen_ty_18 = 0;
pub const xplm_Host_XPlane: _bindgen_ty_18 = 1;
#[doc = " XPLMHostApplicationID"]
#[doc = ""]
#[doc = " While the plug-in SDK is only accessible to plugins running inside X-Plane,"]
#[doc = " the original authors considered extending the API to other applications"]
#[doc = " that shared basic infrastructure with X-Plane. These enumerations are"]
#[doc = " hold-overs from that original roadmap; all values other than X-Plane are"]
#[doc = " deprecated. Your plugin should never need this enumeration."]
#[doc = ""]
pub type _bindgen_ty_18 = ::std::os::raw::c_int;
pub type XPLMHostApplicationID = ::std::os::raw::c_int;
pub const xplm_Language_Unknown: _bindgen_ty_19 = 0;
pub const xplm_Language_English: _bindgen_ty_19 = 1;
pub const xplm_Language_French: _bindgen_ty_19 = 2;
pub const xplm_Language_German: _bindgen_ty_19 = 3;
pub const xplm_Language_Italian: _bindgen_ty_19 = 4;
pub const xplm_Language_Spanish: _bindgen_ty_19 = 5;
pub const xplm_Language_Korean: _bindgen_ty_19 = 6;
pub const xplm_Language_Russian: _bindgen_ty_19 = 7;
pub const xplm_Language_Greek: _bindgen_ty_19 = 8;
pub const xplm_Language_Japanese: _bindgen_ty_19 = 9;
pub const xplm_Language_Chinese: _bindgen_ty_19 = 10;
#[doc = " XPLMLanguageCode"]
#[doc = ""]
#[doc = " These enums define what language the sim is running in. These enumerations"]
#[doc = " do not imply that the sim can or does run in all of these languages; they"]
#[doc = " simply provide a known encoding in the event that a given sim version is"]
#[doc = " localized to a certain language."]
#[doc = ""]
pub type _bindgen_ty_19 = ::std::os::raw::c_int;
pub type XPLMLanguageCode = ::std::os::raw::c_int;
#[doc = " XPLMError_f"]
#[doc = ""]
#[doc = " An XPLM error callback is a function that you provide to receive debugging"]
#[doc = " information from the plugin SDK. See XPLMSetErrorCallback for more"]
#[doc = " information. NOTE: for the sake of debugging, your error callback will be"]
#[doc = " called even if your plugin is not enabled, allowing you to receive debug"]
#[doc = " info in your XPluginStart and XPluginStop callbacks. To avoid causing logic"]
#[doc = " errors in the management code, do not call any other plugin routines from"]
#[doc = " your error callback - it is only meant for catching errors in the"]
#[doc = " debugging."]
#[doc = ""]
pub type XPLMError_f =
    ::std::option::Option<unsafe extern "C" fn(inMessage: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " XPLMGetVersions"]
    #[doc = ""]
    #[doc = " This routine returns the revision of both X-Plane and the XPLM DLL. All"]
    #[doc = " versions are three-digit decimal numbers (e.g. 606 for version 6.06 of"]
    #[doc = " X-Plane); the current revision of the XPLM is 200 (2.00). This routine also"]
    #[doc = " returns the host ID of the app running us."]
    #[doc = ""]
    #[doc = " The most common use of this routine is to special-case around X-Plane"]
    #[doc = " version-specific behavior."]
    #[doc = ""]
    pub fn XPLMGetVersions(
        outXPlaneVersion: *mut ::std::os::raw::c_int,
        outXPLMVersion: *mut ::std::os::raw::c_int,
        outHostID: *mut XPLMHostApplicationID,
    );
}
extern "C" {
    #[doc = " XPLMGetLanguage"]
    #[doc = ""]
    #[doc = " This routine returns the langauge the sim is running in."]
    #[doc = ""]
    pub fn XPLMGetLanguage() -> XPLMLanguageCode;
}
extern "C" {
    #[doc = " XPLMFindSymbol"]
    #[doc = ""]
    #[doc = " This routine will attempt to find the symbol passed in the inString"]
    #[doc = " parameter. If the symbol is found a pointer the function is returned,"]
    #[doc = " othewise the function will return NULL."]
    #[doc = ""]
    #[doc = " You can use XPLMFindSymbol to utilize newer SDK API features without"]
    #[doc = " requiring newer versions of the SDK (and X-Plane) as your minimum X-Plane"]
    #[doc = " version as follows:"]
    #[doc = ""]
    #[doc = "  * Define the XPLMnnn macro to the minimum required XPLM version you will"]
    #[doc = "    ship with (e.g. XPLM210 for X-Plane 10 compatibility)."]
    #[doc = ""]
    #[doc = "  * Use XPLMGetVersions and XPLMFindSymbol to detect that the host sim is"]
    #[doc = "    new enough to use new functions and resolve function pointers."]
    #[doc = ""]
    #[doc = "  * Conditionally use the new functions if and only if XPLMFindSymbol only"]
    #[doc = "    returns a non- NULL pointer."]
    #[doc = ""]
    #[doc = " Warning: you should always check the XPLM API version as well as the"]
    #[doc = " results of XPLMFindSymbol to determine if funtionality is safe to use."]
    #[doc = ""]
    #[doc = " To use functionality via XPLMFindSymbol you will need to copy your own"]
    #[doc = " definitions of the X-Plane API prototypes and cast the returned pointer to"]
    #[doc = " the correct type."]
    #[doc = ""]
    pub fn XPLMFindSymbol(inString: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " XPLMSetErrorCallback"]
    #[doc = ""]
    #[doc = " XPLMSetErrorCallback installs an error-reporting callback for your plugin."]
    #[doc = " Normally the plugin system performs minimum diagnostics to maximize"]
    #[doc = " performance. When you install an error callback, you will receive calls due"]
    #[doc = " to certain plugin errors, such as passing bad parameters or incorrect data."]
    #[doc = ""]
    #[doc = " Important: the error callback determines *programming* errors, e.g. bad API"]
    #[doc = " parameters. Every error that is returned by the error callback represents a"]
    #[doc = " mistake in your plugin that you should fix. Error callbacks are not used to"]
    #[doc = " report expected run-time problems (e.g. disk I/O errors)."]
    #[doc = ""]
    #[doc = " The intention is for you to install the error callback during debug"]
    #[doc = " sections and put a break-point inside your callback. This will cause you to"]
    #[doc = " break into the debugger from within the SDK at the point in your plugin"]
    #[doc = " where you made an illegal call."]
    #[doc = ""]
    #[doc = " Installing an error callback may activate error checking code that would"]
    #[doc = " not normally run, and this may adversely affect performance, so do not"]
    #[doc = " leave error callbacks installed in shipping plugins. Since the only useful"]
    #[doc = " response to an error is to change code, error callbacks are not useful \"in"]
    #[doc = " the field\"."]
    #[doc = ""]
    pub fn XPLMSetErrorCallback(inCallback: XPLMError_f);
}
extern "C" {
    #[doc = " XPLMDebugString"]
    #[doc = ""]
    #[doc = " This routine outputs a C-style string to the Log.txt file. The file is"]
    #[doc = " immediately flushed so you will not lose data. (This does cause a"]
    #[doc = " performance penalty.)"]
    #[doc = ""]
    #[doc = " Please do *not* leave routine diagnostic logging enabled in your shipping"]
    #[doc = " plugin. The X-Plane Log file is shared by X-Plane and every plugin in the"]
    #[doc = " system, and plugins that (when functioning normally) print verbose log"]
    #[doc = " output make it difficult for developers to find error conditions from other"]
    #[doc = " parts of the system."]
    #[doc = ""]
    pub fn XPLMDebugString(inString: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " XPLMSpeakString"]
    #[doc = ""]
    #[doc = " This function displays the string in a translucent overlay over the current"]
    #[doc = " display and also speaks the string if text-to-speech is enabled. The string"]
    #[doc = " is spoken asynchronously, this function returns immediately. This function"]
    #[doc = " may not speak or print depending on user preferences."]
    #[doc = ""]
    pub fn XPLMSpeakString(inString: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " XPLMGetVirtualKeyDescription"]
    #[doc = ""]
    #[doc = " Given a virtual key code (as defined in XPLMDefs.h) this routine returns a"]
    #[doc = " human-readable string describing the character. This routine is provided"]
    #[doc = " for showing users what keyboard mappings they have set up. The string may"]
    #[doc = " read 'unknown' or be a blank or NULL string if the virtual key is unknown."]
    #[doc = ""]
    pub fn XPLMGetVirtualKeyDescription(
        inVirtualKey: ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " XPLMReloadScenery"]
    #[doc = ""]
    #[doc = " XPLMReloadScenery reloads the current set of scenery. You can use this"]
    #[doc = " function in two typical ways: simply call it to reload the scenery, picking"]
    #[doc = " up any new installed scenery, .env files, etc. from disk. Or, change the"]
    #[doc = " lat/ref and lon/ref data refs and then call this function to shift the"]
    #[doc = " scenery environment.  This routine is equivalent to picking \"reload"]
    #[doc = " scenery\" from the developer menu."]
    #[doc = ""]
    pub fn XPLMReloadScenery();
}
#[doc = " The command is being started."]
pub const xplm_CommandBegin: _bindgen_ty_20 = 0;
#[doc = " The command is continuing to execute."]
pub const xplm_CommandContinue: _bindgen_ty_20 = 1;
#[doc = " The command has ended."]
pub const xplm_CommandEnd: _bindgen_ty_20 = 2;
#[doc = " XPLMCommandPhase"]
#[doc = ""]
#[doc = " The phases of a command."]
#[doc = ""]
pub type _bindgen_ty_20 = ::std::os::raw::c_int;
pub type XPLMCommandPhase = ::std::os::raw::c_int;
#[doc = " XPLMCommandRef"]
#[doc = ""]
#[doc = " A command ref is an opaque identifier for an X-Plane command. Command"]
#[doc = " references stay the same for the life of your plugin but not between"]
#[doc = " executions of X-Plane. Command refs are used to execute commands, create"]
#[doc = " commands, and create callbacks for particular commands."]
#[doc = ""]
#[doc = " Note that a command is not \"owned\" by a particular plugin. Since many"]
#[doc = " plugins may participate in a command's execution, the command does not go"]
#[doc = " away if the plugin that created it is unloaded."]
#[doc = ""]
pub type XPLMCommandRef = *mut ::std::os::raw::c_void;
#[doc = " XPLMCommandCallback_f"]
#[doc = ""]
#[doc = " A command callback is a function in your plugin that is called when a"]
#[doc = " command is pressed. Your callback receives the command reference for the"]
#[doc = " particular command, the phase of the command that is executing, and a"]
#[doc = " reference pointer that you specify when registering the callback."]
#[doc = ""]
#[doc = " Your command handler should return 1 to let processing of the command"]
#[doc = " continue to other plugins and X-Plane, or 0 to halt processing, potentially"]
#[doc = " bypassing X-Plane code."]
#[doc = ""]
pub type XPLMCommandCallback_f = ::std::option::Option<
    unsafe extern "C" fn(
        inCommand: XPLMCommandRef,
        inPhase: XPLMCommandPhase,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " XPLMFindCommand"]
    #[doc = ""]
    #[doc = " XPLMFindCommand looks up a command by name, and returns its command"]
    #[doc = " reference or NULL if the command does not exist."]
    #[doc = ""]
    pub fn XPLMFindCommand(inName: *const ::std::os::raw::c_char) -> XPLMCommandRef;
}
extern "C" {
    #[doc = " XPLMCommandBegin"]
    #[doc = ""]
    #[doc = " XPLMCommandBegin starts the execution of a command, specified by its"]
    #[doc = " command reference. The command is \"held down\" until XPLMCommandEnd is"]
    #[doc = " called.  You must balance each XPLMCommandBegin call with an XPLMCommandEnd"]
    #[doc = " call."]
    #[doc = ""]
    pub fn XPLMCommandBegin(inCommand: XPLMCommandRef);
}
extern "C" {
    #[doc = " XPLMCommandEnd"]
    #[doc = ""]
    #[doc = " XPLMCommandEnd ends the execution of a given command that was started with"]
    #[doc = " XPLMCommandBegin.  You must not issue XPLMCommandEnd for a command you did"]
    #[doc = " not begin."]
    #[doc = ""]
    pub fn XPLMCommandEnd(inCommand: XPLMCommandRef);
}
extern "C" {
    #[doc = " XPLMCommandOnce"]
    #[doc = ""]
    #[doc = " This executes a given command momentarily, that is, the command begins and"]
    #[doc = " ends immediately. This is the equivalent of calling XPLMCommandBegin() and"]
    #[doc = " XPLMCommandEnd() back ot back."]
    #[doc = ""]
    pub fn XPLMCommandOnce(inCommand: XPLMCommandRef);
}
extern "C" {
    #[doc = " XPLMCreateCommand"]
    #[doc = ""]
    #[doc = " XPLMCreateCommand creates a new command for a given string. If the command"]
    #[doc = " already exists, the existing command reference is returned. The description"]
    #[doc = " may appear in user interface contexts, such as the joystick configuration"]
    #[doc = " screen."]
    #[doc = ""]
    pub fn XPLMCreateCommand(
        inName: *const ::std::os::raw::c_char,
        inDescription: *const ::std::os::raw::c_char,
    ) -> XPLMCommandRef;
}
extern "C" {
    #[doc = " XPLMRegisterCommandHandler"]
    #[doc = ""]
    #[doc = " XPLMRegisterCommandHandler registers a callback to be called when a command"]
    #[doc = " is executed. You provide a callback with a reference pointer."]
    #[doc = ""]
    #[doc = " If inBefore is true, your command handler callback will be executed before"]
    #[doc = " X-Plane executes the command, and returning 0 from your callback will"]
    #[doc = " disable X-Plane's processing of the command. If inBefore is false, your"]
    #[doc = " callback will run after X-Plane. (You can register a single callback both"]
    #[doc = " before and after a command.)"]
    #[doc = ""]
    pub fn XPLMRegisterCommandHandler(
        inComand: XPLMCommandRef,
        inHandler: XPLMCommandCallback_f,
        inBefore: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMUnregisterCommandHandler"]
    #[doc = ""]
    #[doc = " XPLMUnregisterCommandHandler removes a command callback registered with"]
    #[doc = " XPLMRegisterCommandHandler."]
    #[doc = ""]
    pub fn XPLMUnregisterCommandHandler(
        inComand: XPLMCommandRef,
        inHandler: XPLMCommandCallback_f,
        inBefore: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
#[doc = " there is no symbol to the left of the menu item."]
pub const xplm_Menu_NoCheck: _bindgen_ty_21 = 0;
#[doc = " the menu has a mark next to it that is unmarked (not lit)."]
pub const xplm_Menu_Unchecked: _bindgen_ty_21 = 1;
#[doc = " the menu has a mark next to it that is checked (lit)."]
pub const xplm_Menu_Checked: _bindgen_ty_21 = 2;
#[doc = " XPLMMenuCheck"]
#[doc = ""]
#[doc = " These enumerations define the various 'check' states for an X-Plane menu."]
#[doc = " 'checking' in X-Plane actually appears as a light which may or may not be"]
#[doc = " lit.  So there are three possible states."]
#[doc = ""]
pub type _bindgen_ty_21 = ::std::os::raw::c_int;
pub type XPLMMenuCheck = ::std::os::raw::c_int;
#[doc = " XPLMMenuID"]
#[doc = ""]
#[doc = " This is a unique ID for each menu you create."]
#[doc = ""]
pub type XPLMMenuID = *mut ::std::os::raw::c_void;
#[doc = " XPLMMenuHandler_f"]
#[doc = ""]
#[doc = " A menu handler function takes two reference pointers, one for the menu"]
#[doc = " (specified when the menu was created) and one for the item (specified when"]
#[doc = " the item was created)."]
#[doc = ""]
pub type XPLMMenuHandler_f = ::std::option::Option<
    unsafe extern "C" fn(
        inMenuRef: *mut ::std::os::raw::c_void,
        inItemRef: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " XPLMFindPluginsMenu"]
    #[doc = ""]
    #[doc = " This function returns the ID of the plug-ins menu, which is created for you"]
    #[doc = " at startup."]
    #[doc = ""]
    pub fn XPLMFindPluginsMenu() -> XPLMMenuID;
}
extern "C" {
    #[doc = " XPLMFindAircraftMenu"]
    #[doc = ""]
    #[doc = " This function returns the ID of the menu for the currently-loaded aircraft,"]
    #[doc = " used for showing aircraft-specific commands."]
    #[doc = ""]
    #[doc = " The aircraft menu is created by X-Plane at startup, but it remains hidden"]
    #[doc = " until it is populated via XPLMAppendMenuItem() or"]
    #[doc = " XPLMAppendMenuItemWithCommand()."]
    #[doc = ""]
    #[doc = " Only plugins loaded with the user's current aircraft are allowed to access"]
    #[doc = " the aircraft menu. For all other plugins, this will return NULL, and any"]
    #[doc = " attempts to add menu items to it will fail."]
    #[doc = ""]
    pub fn XPLMFindAircraftMenu() -> XPLMMenuID;
}
extern "C" {
    #[doc = " XPLMCreateMenu"]
    #[doc = ""]
    #[doc = " This function creates a new menu and returns its ID.  It returns NULL if"]
    #[doc = " the menu cannot be created.  Pass in a parent menu ID and an item index to"]
    #[doc = " create a submenu, or NULL for the parent menu to put the menu in the menu"]
    #[doc = " bar.  The menu's name is only used if the menu is in the menubar.  You also"]
    #[doc = " pass a handler function and a menu reference value. Pass NULL for the"]
    #[doc = " handler if you do not need callbacks from the menu (for example, if it only"]
    #[doc = " contains submenus)."]
    #[doc = ""]
    #[doc = " Important: you must pass a valid, non-empty menu title even if the menu is"]
    #[doc = " a submenu where the title is not visible."]
    #[doc = ""]
    pub fn XPLMCreateMenu(
        inName: *const ::std::os::raw::c_char,
        inParentMenu: XPLMMenuID,
        inParentItem: ::std::os::raw::c_int,
        inHandler: XPLMMenuHandler_f,
        inMenuRef: *mut ::std::os::raw::c_void,
    ) -> XPLMMenuID;
}
extern "C" {
    #[doc = " XPLMDestroyMenu"]
    #[doc = ""]
    #[doc = " This function destroys a menu that you have created.  Use this to remove a"]
    #[doc = " submenu if necessary.  (Normally this function will not be necessary.)"]
    #[doc = ""]
    pub fn XPLMDestroyMenu(inMenuID: XPLMMenuID);
}
extern "C" {
    #[doc = " XPLMClearAllMenuItems"]
    #[doc = ""]
    #[doc = " This function removes all menu items from a menu, allowing you to rebuild"]
    #[doc = " it.  Use this function if you need to change the number of items on a menu."]
    #[doc = ""]
    pub fn XPLMClearAllMenuItems(inMenuID: XPLMMenuID);
}
extern "C" {
    #[doc = " XPLMAppendMenuItem"]
    #[doc = ""]
    #[doc = " This routine appends a new menu item to the bottom of a menu and returns"]
    #[doc = " its index. Pass in the menu to add the item to, the items name, and a void"]
    #[doc = " * ref for this item."]
    #[doc = ""]
    #[doc = " Returns a negative index if the append failed (due to an invalid parent"]
    #[doc = " menu argument)."]
    #[doc = ""]
    #[doc = " Note that all menu indices returned are relative to your plugin's menus"]
    #[doc = " only; if your plugin creates two sub-menus in the Plugins menu at different"]
    #[doc = " times, it doesn't matter how many other plugins also create sub-menus of"]
    #[doc = " Plugins in the intervening time: your sub-menus will be given menu indices"]
    #[doc = " 0 and 1. (The SDK does some work in the back-end to filter out menus that"]
    #[doc = " are irrelevant to your plugin in order to deliver this consistency for each"]
    #[doc = " plugin.)"]
    #[doc = ""]
    pub fn XPLMAppendMenuItem(
        inMenu: XPLMMenuID,
        inItemName: *const ::std::os::raw::c_char,
        inItemRef: *mut ::std::os::raw::c_void,
        inDeprecatedAndIgnored: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMAppendMenuItemWithCommand"]
    #[doc = ""]
    #[doc = " Like XPLMAppendMenuItem(), but instead of the new menu item triggering the"]
    #[doc = " XPLMMenuHandler_f of the containiner menu, it will simply execute the"]
    #[doc = " command you pass in. Using a command for your menu item allows the user to"]
    #[doc = " bind a keyboard shortcut to the command and see that shortcut represented"]
    #[doc = " in the menu."]
    #[doc = ""]
    #[doc = " Returns a negative index if the append failed (due to an invalid parent"]
    #[doc = " menu argument)."]
    #[doc = ""]
    #[doc = " Like XPLMAppendMenuItem(), all menu indices are relative to your plugin's"]
    #[doc = " menus only."]
    #[doc = ""]
    pub fn XPLMAppendMenuItemWithCommand(
        inMenu: XPLMMenuID,
        inItemName: *const ::std::os::raw::c_char,
        inCommandToExecute: XPLMCommandRef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMAppendMenuSeparator"]
    #[doc = ""]
    #[doc = " This routine adds a separator to the end of a menu."]
    #[doc = ""]
    #[doc = " Returns a negative index if the append failed (due to an invalid parent"]
    #[doc = " menu argument)."]
    #[doc = ""]
    pub fn XPLMAppendMenuSeparator(inMenu: XPLMMenuID);
}
extern "C" {
    #[doc = " XPLMSetMenuItemName"]
    #[doc = ""]
    #[doc = " This routine changes the name of an existing menu item.  Pass in the menu"]
    #[doc = " ID and the index of the menu item."]
    #[doc = ""]
    pub fn XPLMSetMenuItemName(
        inMenu: XPLMMenuID,
        inIndex: ::std::os::raw::c_int,
        inItemName: *const ::std::os::raw::c_char,
        inDeprecatedAndIgnored: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMCheckMenuItem"]
    #[doc = ""]
    #[doc = " Set whether a menu item is checked.  Pass in the menu ID and item index."]
    #[doc = ""]
    pub fn XPLMCheckMenuItem(
        inMenu: XPLMMenuID,
        index: ::std::os::raw::c_int,
        inCheck: XPLMMenuCheck,
    );
}
extern "C" {
    #[doc = " XPLMCheckMenuItemState"]
    #[doc = ""]
    #[doc = " This routine returns whether a menu item is checked or not. A menu item's"]
    #[doc = " check mark may be on or off, or a menu may not have an icon at all."]
    #[doc = ""]
    pub fn XPLMCheckMenuItemState(
        inMenu: XPLMMenuID,
        index: ::std::os::raw::c_int,
        outCheck: *mut XPLMMenuCheck,
    );
}
extern "C" {
    #[doc = " XPLMEnableMenuItem"]
    #[doc = ""]
    #[doc = " Sets whether this menu item is enabled.  Items start out enabled."]
    #[doc = ""]
    pub fn XPLMEnableMenuItem(
        inMenu: XPLMMenuID,
        index: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMRemoveMenuItem"]
    #[doc = ""]
    #[doc = " Removes one item from a menu.  Note that all menu items below are moved up"]
    #[doc = " one; your plugin must track the change in index numbers."]
    #[doc = ""]
    pub fn XPLMRemoveMenuItem(inMenu: XPLMMenuID, inIndex: ::std::os::raw::c_int);
}
pub const xplm_Nav_Unknown: _bindgen_ty_22 = 0;
pub const xplm_Nav_Airport: _bindgen_ty_22 = 1;
pub const xplm_Nav_NDB: _bindgen_ty_22 = 2;
pub const xplm_Nav_VOR: _bindgen_ty_22 = 4;
pub const xplm_Nav_ILS: _bindgen_ty_22 = 8;
pub const xplm_Nav_Localizer: _bindgen_ty_22 = 16;
pub const xplm_Nav_GlideSlope: _bindgen_ty_22 = 32;
pub const xplm_Nav_OuterMarker: _bindgen_ty_22 = 64;
pub const xplm_Nav_MiddleMarker: _bindgen_ty_22 = 128;
pub const xplm_Nav_InnerMarker: _bindgen_ty_22 = 256;
pub const xplm_Nav_Fix: _bindgen_ty_22 = 512;
pub const xplm_Nav_DME: _bindgen_ty_22 = 1024;
pub const xplm_Nav_LatLon: _bindgen_ty_22 = 2048;
#[doc = " XPLMNavType"]
#[doc = ""]
#[doc = " These enumerations define the different types of navaids.  They are each"]
#[doc = " defined with a separate bit so that they may be bit-wise added together to"]
#[doc = " form sets of nav-aid types."]
#[doc = ""]
#[doc = " NOTE: xplm_Nav_LatLon is a specific lat-lon coordinate entered into the"]
#[doc = " FMS. It will not exist in the database, and cannot be programmed into the"]
#[doc = " FMS. Querying the FMS for navaids will return it.  Use"]
#[doc = " XPLMSetFMSEntryLatLon to set a lat/lon waypoint."]
#[doc = ""]
pub type _bindgen_ty_22 = ::std::os::raw::c_int;
pub type XPLMNavType = ::std::os::raw::c_int;
#[doc = " XPLMNavRef"]
#[doc = ""]
#[doc = " XPLMNavRef is an iterator into the navigation database.  The navigation"]
#[doc = " database is essentially an array, but it is not necessarily densely"]
#[doc = " populated. The only assumption you can safely make is that like-typed"]
#[doc = " nav-aids are grouped together."]
#[doc = ""]
#[doc = " Use XPLMNavRef to refer to a nav-aid."]
#[doc = ""]
#[doc = " XPLM_NAV_NOT_FOUND is returned by functions that return an XPLMNavRef when"]
#[doc = " the iterator must be invalid."]
#[doc = ""]
pub type XPLMNavRef = ::std::os::raw::c_int;
extern "C" {
    #[doc = " XPLMGetFirstNavAid"]
    #[doc = ""]
    #[doc = " This returns the very first navaid in the database.  Use this to traverse"]
    #[doc = " the entire database.  Returns XPLM_NAV_NOT_FOUND if the nav database is"]
    #[doc = " empty."]
    #[doc = ""]
    pub fn XPLMGetFirstNavAid() -> XPLMNavRef;
}
extern "C" {
    #[doc = " XPLMGetNextNavAid"]
    #[doc = ""]
    #[doc = " Given a valid nav aid ref, this routine returns the next navaid.  It"]
    #[doc = " returns XPLM_NAV_NOT_FOUND if the nav aid passed in was invalid or if the"]
    #[doc = " navaid passed in was the last one in the database.  Use this routine to"]
    #[doc = " iterate across all like-typed navaids or the entire database."]
    #[doc = ""]
    pub fn XPLMGetNextNavAid(inNavAidRef: XPLMNavRef) -> XPLMNavRef;
}
extern "C" {
    #[doc = " XPLMFindFirstNavAidOfType"]
    #[doc = ""]
    #[doc = " This routine returns the ref of the first navaid of the given type in the"]
    #[doc = " database or XPLM_NAV_NOT_FOUND if there are no navaids of that type in the"]
    #[doc = " database.  You must pass exactly one nav aid type to this routine."]
    #[doc = ""]
    pub fn XPLMFindFirstNavAidOfType(inType: XPLMNavType) -> XPLMNavRef;
}
extern "C" {
    #[doc = " XPLMFindLastNavAidOfType"]
    #[doc = ""]
    #[doc = " This routine returns the ref of the last navaid of the given type in the"]
    #[doc = " database or XPLM_NAV_NOT_FOUND if there are no navaids of that type in the"]
    #[doc = " database.  You must pass exactly one nav aid type to this routine."]
    #[doc = ""]
    pub fn XPLMFindLastNavAidOfType(inType: XPLMNavType) -> XPLMNavRef;
}
extern "C" {
    #[doc = " XPLMFindNavAid"]
    #[doc = ""]
    #[doc = " This routine provides a number of searching capabilities for the nav"]
    #[doc = " database. XPLMFindNavAid will search through every nav aid whose type is"]
    #[doc = " within inType (multiple types may be added together) and return any"]
    #[doc = " nav-aids found based on the following rules:"]
    #[doc = ""]
    #[doc = " * If inLat and inLon are not NULL, the navaid nearest to that lat/lon will"]
    #[doc = "   be returned, otherwise the last navaid found will be returned."]
    #[doc = ""]
    #[doc = " * If inFrequency is not NULL, then any navaids considered must match this"]
    #[doc = "   frequency.  Note that this will screen out radio beacons that do not have"]
    #[doc = "   frequency data published (like inner markers) but not fixes and airports."]
    #[doc = ""]
    #[doc = " * If inNameFragment is not NULL, only navaids that contain the fragment in"]
    #[doc = "   their name will be returned."]
    #[doc = ""]
    #[doc = " * If inIDFragment is not NULL, only navaids that contain the fragment in"]
    #[doc = "   their IDs will be returned."]
    #[doc = ""]
    #[doc = " This routine provides a simple way to do a number of useful searches:"]
    #[doc = " * Find the nearest navaid on this frequency."]
    #[doc = " * Find the nearest airport."]
    #[doc = " * Find the VOR whose ID is \"KBOS\"."]
    #[doc = " * Find the nearest airport whose name contains \"Chicago\"."]
    #[doc = ""]
    pub fn XPLMFindNavAid(
        inNameFragment: *const ::std::os::raw::c_char,
        inIDFragment: *const ::std::os::raw::c_char,
        inLat: *mut f32,
        inLon: *mut f32,
        inFrequency: *mut ::std::os::raw::c_int,
        inType: XPLMNavType,
    ) -> XPLMNavRef;
}
extern "C" {
    #[doc = " XPLMGetNavAidInfo"]
    #[doc = ""]
    #[doc = " This routine returns information about a navaid.  Any non-null field is"]
    #[doc = " filled out with information if it is available."]
    #[doc = ""]
    #[doc = " Frequencies are in the nav.dat convention as described in the X-Plane nav"]
    #[doc = " database FAQ: NDB frequencies are exact, all others are multiplied by 100."]
    #[doc = ""]
    #[doc = " The buffer for IDs should be at least 6 chars and the buffer for names"]
    #[doc = " should be at least 41 chars, but since these values are likely to go up, I"]
    #[doc = " recommend passing at least 32 chars for IDs and 256 chars for names when"]
    #[doc = " possible."]
    #[doc = ""]
    #[doc = " The outReg parameter tells if the navaid is within the local \"region\" of"]
    #[doc = " loaded DSFs.  (This information may not be particularly useful to plugins.)"]
    #[doc = " The parameter is a single byte value 1 for true or 0 for false, not a C"]
    #[doc = " string."]
    #[doc = ""]
    pub fn XPLMGetNavAidInfo(
        inRef: XPLMNavRef,
        outType: *mut XPLMNavType,
        outLatitude: *mut f32,
        outLongitude: *mut f32,
        outHeight: *mut f32,
        outFrequency: *mut ::std::os::raw::c_int,
        outHeading: *mut f32,
        outID: *mut ::std::os::raw::c_char,
        outName: *mut ::std::os::raw::c_char,
        outReg: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " XPLMCountFMSEntries"]
    #[doc = ""]
    #[doc = " This routine returns the number of entries in the FMS."]
    #[doc = ""]
    pub fn XPLMCountFMSEntries() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMGetDisplayedFMSEntry"]
    #[doc = ""]
    #[doc = " This routine returns the index of the entry the pilot is viewing."]
    #[doc = ""]
    pub fn XPLMGetDisplayedFMSEntry() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMGetDestinationFMSEntry"]
    #[doc = ""]
    #[doc = " This routine returns the index of the entry the FMS is flying to."]
    #[doc = ""]
    pub fn XPLMGetDestinationFMSEntry() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMSetDisplayedFMSEntry"]
    #[doc = ""]
    #[doc = " This routine changes which entry the FMS is showing to the index specified."]
    #[doc = ""]
    pub fn XPLMSetDisplayedFMSEntry(inIndex: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMSetDestinationFMSEntry"]
    #[doc = ""]
    #[doc = " This routine changes which entry the FMS is flying the aircraft toward."]
    #[doc = ""]
    pub fn XPLMSetDestinationFMSEntry(inIndex: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMGetFMSEntryInfo"]
    #[doc = ""]
    #[doc = " This routine returns information about a given FMS entry. If the entry is"]
    #[doc = " an airport or navaid, a reference to a nav entry can be returned allowing"]
    #[doc = " you to find additional information (such as a frequency, ILS heading, name,"]
    #[doc = " etc.). Note that this reference can be XPLM_NAV_NOT_FOUND until the"]
    #[doc = " information has been looked up asynchronously, so after flightplan changes,"]
    #[doc = " it might take up to a second for this field to become populated. The other"]
    #[doc = " information is available immediately. For a lat/lon entry, the lat/lon is"]
    #[doc = " returned by this routine but the navaid cannot be looked up (and the"]
    #[doc = " reference will be XPLM_NAV_NOT_FOUND). FMS name entry buffers should be at"]
    #[doc = " least 256 chars in length."]
    #[doc = ""]
    #[doc = " WARNING: Due to a bug in X-Plane prior to 11.31, the navaid reference will"]
    #[doc = " not be set to XPLM_NAV_NOT_FOUND while no data is available, and instead"]
    #[doc = " just remain the value of the variable that you passed the pointer to."]
    #[doc = " Therefore, always initialize the variable to XPLM_NAV_NOT_FOUND before"]
    #[doc = " passing the pointer to this function."]
    #[doc = ""]
    pub fn XPLMGetFMSEntryInfo(
        inIndex: ::std::os::raw::c_int,
        outType: *mut XPLMNavType,
        outID: *mut ::std::os::raw::c_char,
        outRef: *mut XPLMNavRef,
        outAltitude: *mut ::std::os::raw::c_int,
        outLat: *mut f32,
        outLon: *mut f32,
    );
}
extern "C" {
    #[doc = " XPLMSetFMSEntryInfo"]
    #[doc = ""]
    #[doc = " This routine changes an entry in the FMS to have the destination navaid"]
    #[doc = " passed in and the altitude specified.  Use this only for airports, fixes,"]
    #[doc = " and radio-beacon navaids.  Currently of radio beacons, the FMS can only"]
    #[doc = " support VORs and NDBs. Use the routines below to clear or fly to a lat/lon."]
    #[doc = ""]
    pub fn XPLMSetFMSEntryInfo(
        inIndex: ::std::os::raw::c_int,
        inRef: XPLMNavRef,
        inAltitude: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMSetFMSEntryLatLon"]
    #[doc = ""]
    #[doc = " This routine changes the entry in the FMS to a lat/lon entry with the given"]
    #[doc = " coordinates."]
    #[doc = ""]
    pub fn XPLMSetFMSEntryLatLon(
        inIndex: ::std::os::raw::c_int,
        inLat: f32,
        inLon: f32,
        inAltitude: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMClearFMSEntry"]
    #[doc = ""]
    #[doc = " This routine clears the given entry, potentially shortening the flight"]
    #[doc = " plan."]
    #[doc = ""]
    pub fn XPLMClearFMSEntry(inIndex: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMGetGPSDestinationType"]
    #[doc = ""]
    #[doc = " This routine returns the type of the currently selected GPS destination,"]
    #[doc = " one of fix, airport, VOR or NDB."]
    #[doc = ""]
    pub fn XPLMGetGPSDestinationType() -> XPLMNavType;
}
extern "C" {
    #[doc = " XPLMGetGPSDestination"]
    #[doc = ""]
    #[doc = " This routine returns the current GPS destination."]
    #[doc = ""]
    pub fn XPLMGetGPSDestination() -> XPLMNavRef;
}
extern "C" {
    #[doc = " XPLMSetUsersAircraft"]
    #[doc = ""]
    #[doc = " This routine changes the user's aircraft.  Note that this will reinitialize"]
    #[doc = " the user to be on the nearest airport's first runway.  Pass in a full path"]
    #[doc = " (hard drive and everything including the .acf extension) to the .acf file."]
    #[doc = ""]
    pub fn XPLMSetUsersAircraft(inAircraftPath: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " XPLMPlaceUserAtAirport"]
    #[doc = ""]
    #[doc = " This routine places the user at a given airport.  Specify the airport by"]
    #[doc = " its X-Plane airport ID (e.g. 'KBOS')."]
    #[doc = ""]
    pub fn XPLMPlaceUserAtAirport(inAirportCode: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " XPLMPlaceUserAtLocation"]
    #[doc = ""]
    #[doc = " Places the user at a specific location after performing any necessary"]
    #[doc = " scenery loads."]
    #[doc = ""]
    #[doc = " As with in-air starts initiated from the X-Plane user interface, the"]
    #[doc = " aircraft will always start with its engines running, regardless of the"]
    #[doc = " user's preferences (i.e., regardless of what the dataref"]
    #[doc = " `sim/operation/prefs/startup_running` says)."]
    #[doc = ""]
    pub fn XPLMPlaceUserAtLocation(
        latitudeDegrees: f64,
        longitudeDegrees: f64,
        elevationMetersMSL: f32,
        headingDegreesTrue: f32,
        speedMetersPerSecond: f32,
    );
}
extern "C" {
    #[doc = " XPLMCountAircraft"]
    #[doc = ""]
    #[doc = " This function returns the number of aircraft X-Plane is capable of having,"]
    #[doc = " as well as the number of aircraft that are currently active.  These numbers"]
    #[doc = " count the user's aircraft.  It can also return the plugin that is currently"]
    #[doc = " controlling aircraft.  In X-Plane 7, this routine reflects the number of"]
    #[doc = " aircraft the user has enabled in the rendering options window."]
    #[doc = ""]
    pub fn XPLMCountAircraft(
        outTotalAircraft: *mut ::std::os::raw::c_int,
        outActiveAircraft: *mut ::std::os::raw::c_int,
        outController: *mut XPLMPluginID,
    );
}
extern "C" {
    #[doc = " XPLMGetNthAircraftModel"]
    #[doc = ""]
    #[doc = " This function returns the aircraft model for the Nth aircraft.  Indices are"]
    #[doc = " zero based, with zero being the user's aircraft.  The file name should be"]
    #[doc = " at least 256 chars in length; the path should be at least 512 chars in"]
    #[doc = " length."]
    #[doc = ""]
    pub fn XPLMGetNthAircraftModel(
        inIndex: ::std::os::raw::c_int,
        outFileName: *mut ::std::os::raw::c_char,
        outPath: *mut ::std::os::raw::c_char,
    );
}
#[doc = " XPLMPlanesAvailable_f"]
#[doc = ""]
#[doc = " Your airplanes available callback is called when another plugin gives up"]
#[doc = " access to the multiplayer planes.  Use this to wait for access to"]
#[doc = " multiplayer."]
#[doc = ""]
pub type XPLMPlanesAvailable_f =
    ::std::option::Option<unsafe extern "C" fn(inRefcon: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " XPLMAcquirePlanes"]
    #[doc = ""]
    #[doc = " XPLMAcquirePlanes grants your plugin exclusive access to the aircraft.  It"]
    #[doc = " returns 1 if you gain access, 0 if you do not."]
    #[doc = ""]
    #[doc = " inAircraft - pass in an array of pointers to strings specifying the planes"]
    #[doc = " you want loaded.  For any plane index you do not want loaded, pass a"]
    #[doc = " 0-length string.  Other strings should be full paths with the .acf"]
    #[doc = " extension.  NULL terminates this array, or pass NULL if there are no planes"]
    #[doc = " you want loaded."]
    #[doc = ""]
    #[doc = " If you pass in a callback and do not receive access to the planes your"]
    #[doc = " callback will be called when the airplanes are available. If you do receive"]
    #[doc = " airplane access, your callback will not be called."]
    #[doc = ""]
    pub fn XPLMAcquirePlanes(
        inAircraft: *mut *mut ::std::os::raw::c_char,
        inCallback: XPLMPlanesAvailable_f,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMReleasePlanes"]
    #[doc = ""]
    #[doc = " Call this function to release access to the planes.  Note that if you are"]
    #[doc = " disabled, access to planes is released for you and you must reacquire it."]
    #[doc = ""]
    pub fn XPLMReleasePlanes();
}
extern "C" {
    #[doc = " XPLMSetActiveAircraftCount"]
    #[doc = ""]
    #[doc = " This routine sets the number of active planes.  If you pass in a number"]
    #[doc = " higher than the total number of planes availables, only the total number of"]
    #[doc = " planes available is actually used."]
    #[doc = ""]
    pub fn XPLMSetActiveAircraftCount(inCount: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMSetAircraftModel"]
    #[doc = ""]
    #[doc = " This routine loads an aircraft model.  It may only be called if you have"]
    #[doc = " exclusive access to the airplane APIs.  Pass in the path of the model with"]
    #[doc = " the .acf extension.  The index is zero based, but you may not pass in 0"]
    #[doc = " (use XPLMSetUsersAircraft to load the user's aircracft)."]
    #[doc = ""]
    pub fn XPLMSetAircraftModel(
        inIndex: ::std::os::raw::c_int,
        inAircraftPath: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " XPLMDisableAIForPlane"]
    #[doc = ""]
    #[doc = " This routine turns off X-Plane's AI for a given plane.  The plane will"]
    #[doc = " continue to draw and be a real plane in X-Plane, but will not move itself."]
    #[doc = ""]
    pub fn XPLMDisableAIForPlane(inPlaneIndex: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " XPLMGetMyID"]
    #[doc = ""]
    #[doc = " This routine returns the plugin ID of the calling plug-in.  Call this to"]
    #[doc = " get your own ID."]
    #[doc = ""]
    pub fn XPLMGetMyID() -> XPLMPluginID;
}
extern "C" {
    #[doc = " XPLMCountPlugins"]
    #[doc = ""]
    #[doc = " This routine returns the total number of plug-ins that are loaded, both"]
    #[doc = " disabled and enabled."]
    #[doc = ""]
    pub fn XPLMCountPlugins() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMGetNthPlugin"]
    #[doc = ""]
    #[doc = " This routine returns the ID of a plug-in by index.  Index is 0 based from 0"]
    #[doc = " to XPLMCountPlugins-1, inclusive. Plugins may be returned in any arbitrary"]
    #[doc = " order."]
    #[doc = ""]
    pub fn XPLMGetNthPlugin(inIndex: ::std::os::raw::c_int) -> XPLMPluginID;
}
extern "C" {
    #[doc = " XPLMFindPluginByPath"]
    #[doc = ""]
    #[doc = " This routine returns the plug-in ID of the plug-in whose file exists at the"]
    #[doc = " passed in absolute file system path.  XPLM_NO_PLUGIN_ID is returned if the"]
    #[doc = " path does not point to a currently loaded plug-in."]
    #[doc = ""]
    pub fn XPLMFindPluginByPath(inPath: *const ::std::os::raw::c_char) -> XPLMPluginID;
}
extern "C" {
    #[doc = " XPLMFindPluginBySignature"]
    #[doc = ""]
    #[doc = " This routine returns the plug-in ID of the plug-in whose signature matches"]
    #[doc = " what is passed in or XPLM_NO_PLUGIN_ID if no running plug-in has this"]
    #[doc = " signature.  Signatures are the best way to identify another plug-in as they"]
    #[doc = " are independent of the file system path of a plug-in or the human-readable"]
    #[doc = " plug-in name, and should be unique for all plug-ins.  Use this routine to"]
    #[doc = " locate another plugin that your plugin interoperates with"]
    #[doc = ""]
    pub fn XPLMFindPluginBySignature(inSignature: *const ::std::os::raw::c_char) -> XPLMPluginID;
}
extern "C" {
    #[doc = " XPLMGetPluginInfo"]
    #[doc = ""]
    #[doc = " This routine returns information about a plug-in.  Each parameter should be"]
    #[doc = " a pointer to a buffer of at least"]
    #[doc = " 256 characters, or NULL to not receive the information."]
    #[doc = ""]
    #[doc = " outName - the human-readable name of the plug-in. outFilePath - the"]
    #[doc = " absolute file path to the file that contains this plug-in. outSignature - a"]
    #[doc = " unique string that identifies this plug-in. outDescription - a"]
    #[doc = " human-readable description of this plug-in."]
    #[doc = ""]
    pub fn XPLMGetPluginInfo(
        inPlugin: XPLMPluginID,
        outName: *mut ::std::os::raw::c_char,
        outFilePath: *mut ::std::os::raw::c_char,
        outSignature: *mut ::std::os::raw::c_char,
        outDescription: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " XPLMIsPluginEnabled"]
    #[doc = ""]
    #[doc = " Returns whether the specified plug-in is enabled for running."]
    #[doc = ""]
    pub fn XPLMIsPluginEnabled(inPluginID: XPLMPluginID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMEnablePlugin"]
    #[doc = ""]
    #[doc = " This routine enables a plug-in if it is not already enabled. It returns 1"]
    #[doc = " if the plugin was enabled or successfully enables itself, 0 if it does not."]
    #[doc = " Plugins may fail to enable (for example, if resources cannot be acquired)"]
    #[doc = " by returning 0 from their XPluginEnable callback."]
    #[doc = ""]
    pub fn XPLMEnablePlugin(inPluginID: XPLMPluginID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMDisablePlugin"]
    #[doc = ""]
    #[doc = " This routine disableds an enabled plug-in."]
    #[doc = ""]
    pub fn XPLMDisablePlugin(inPluginID: XPLMPluginID);
}
extern "C" {
    #[doc = " XPLMReloadPlugins"]
    #[doc = ""]
    #[doc = " This routine reloads all plug-ins.  Once this routine is called and you"]
    #[doc = " return from the callback you were within (e.g. a menu select callback) you"]
    #[doc = " will receive your XPluginDisable and XPluginStop callbacks and your DLL"]
    #[doc = " will be unloaded, then the start process happens as if the sim was starting"]
    #[doc = " up."]
    #[doc = ""]
    pub fn XPLMReloadPlugins();
}
extern "C" {
    #[doc = " XPLMSendMessageToPlugin"]
    #[doc = ""]
    #[doc = " This function sends a message to another plug-in or X-Plane.  Pass"]
    #[doc = " XPLM_NO_PLUGIN_ID to broadcast to all plug-ins.  Only enabled plug-ins with"]
    #[doc = " a message receive function receive the message."]
    #[doc = ""]
    pub fn XPLMSendMessageToPlugin(
        inPlugin: XPLMPluginID,
        inMessage: ::std::os::raw::c_int,
        inParam: *mut ::std::os::raw::c_void,
    );
}
#[doc = " XPLMFeatureEnumerator_f"]
#[doc = ""]
#[doc = " You pass an XPLMFeatureEnumerator_f to get a list of all features supported"]
#[doc = " by a given version running version of X-Plane.  This routine is called once"]
#[doc = " for each feature."]
#[doc = ""]
pub type XPLMFeatureEnumerator_f = ::std::option::Option<
    unsafe extern "C" fn(
        inFeature: *const ::std::os::raw::c_char,
        inRef: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " XPLMHasFeature"]
    #[doc = ""]
    #[doc = " This returns 1 if the given installation of X-Plane supports a feature, or"]
    #[doc = " 0 if it does not."]
    #[doc = ""]
    pub fn XPLMHasFeature(inFeature: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMIsFeatureEnabled"]
    #[doc = ""]
    #[doc = " This returns 1 if a feature is currently enabled for your plugin, or 0 if"]
    #[doc = " it is not enabled.  It is an error to call this routine with an unsupported"]
    #[doc = " feature."]
    #[doc = ""]
    pub fn XPLMIsFeatureEnabled(inFeature: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMEnableFeature"]
    #[doc = ""]
    #[doc = " This routine enables or disables a feature for your plugin.  This will"]
    #[doc = " change the running behavior of X-Plane and your plugin in some way,"]
    #[doc = " depending on the feature."]
    #[doc = ""]
    pub fn XPLMEnableFeature(
        inFeature: *const ::std::os::raw::c_char,
        inEnable: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " XPLMEnumerateFeatures"]
    #[doc = ""]
    #[doc = " This routine calls your enumerator callback once for each feature that this"]
    #[doc = " running version of X-Plane supports. Use this routine to determine all of"]
    #[doc = " the features that X-Plane can support."]
    #[doc = ""]
    pub fn XPLMEnumerateFeatures(
        inEnumerator: XPLMFeatureEnumerator_f,
        inRef: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Your callback runs before X-Plane integrates the flight model."]
pub const xplm_FlightLoop_Phase_BeforeFlightModel: _bindgen_ty_23 = 0;
#[doc = " Your callback runs after X-Plane integrates the flight model."]
pub const xplm_FlightLoop_Phase_AfterFlightModel: _bindgen_ty_23 = 1;
#[doc = " XPLMFlightLoopPhaseType"]
#[doc = ""]
#[doc = " You can register a flight loop callback to run either before or after the"]
#[doc = " flight model is integrated by X-Plane."]
#[doc = ""]
pub type _bindgen_ty_23 = ::std::os::raw::c_int;
pub type XPLMFlightLoopPhaseType = ::std::os::raw::c_int;
#[doc = " XPLMFlightLoopID"]
#[doc = ""]
#[doc = " This is an opaque identifier for a flight loop callback. You can use this"]
#[doc = " identifier to easily track and remove your callbacks, or to use the new"]
#[doc = " flight loop APIs."]
#[doc = ""]
pub type XPLMFlightLoopID = *mut ::std::os::raw::c_void;
#[doc = " XPLMFlightLoop_f"]
#[doc = ""]
#[doc = " This is your flight loop callback. Each time the flight loop is iterated"]
#[doc = " through, you receive this call at the end."]
#[doc = ""]
#[doc = " Flight loop callbacks receive a number of input timing parameters. These"]
#[doc = " input timing parameters are not particularly useful; you may need to track"]
#[doc = " your own timing data (e.g. by reading datarefs). The input parameters are:"]
#[doc = ""]
#[doc = " - inElapsedSinceLastCall: the wall time since your last callback."]
#[doc = " - inElapsedTimeSinceLastFlightLoop: the wall time since any flight loop was"]
#[doc = "   dispatched."]
#[doc = " - inCounter: a monotonically increasing counter, bumped once per flight"]
#[doc = "   loop dispatch from the sim."]
#[doc = " - inRefcon: your own ptr constant from when you regitered yor callback."]
#[doc = ""]
#[doc = " Your return value controls when you will next be called."]
#[doc = ""]
#[doc = "  - Return 0 to stop receiving callbacks."]
#[doc = "  - Pass a positive number to specify how many seconds until the next"]
#[doc = "    callback. (You will be called at or after this time, not before.)"]
#[doc = "  - Pass a negative number to specify how many loops must go by until you"]
#[doc = "    are called. For example, -1.0 means call me the very next loop."]
#[doc = ""]
#[doc = " Try to run your flight loop as infrequently as is practical, and suspend it"]
#[doc = " (using return value 0) when you do not need it; lots of flight loop"]
#[doc = " callbacks that do nothing lowers X-Plane's frame rate."]
#[doc = ""]
#[doc = " Your callback will NOT be unregistered if you return 0; it will merely be"]
#[doc = " inactive."]
#[doc = ""]
pub type XPLMFlightLoop_f = ::std::option::Option<
    unsafe extern "C" fn(
        inElapsedSinceLastCall: f32,
        inElapsedTimeSinceLastFlightLoop: f32,
        inCounter: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    ) -> f32,
>;
#[doc = " XPLMCreateFlightLoop_t"]
#[doc = ""]
#[doc = " XPLMCreateFlightLoop_t contains the parameters to create a new flight loop"]
#[doc = " callback. The strsucture can be expanded in future SDKs - always set"]
#[doc = " structSize to the size of your structure in bytes."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XPLMCreateFlightLoop_t {
    pub structSize: ::std::os::raw::c_int,
    pub phase: XPLMFlightLoopPhaseType,
    pub callbackFunc: XPLMFlightLoop_f,
    pub refcon: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_XPLMCreateFlightLoop_t() {
    const UNINIT: ::std::mem::MaybeUninit<XPLMCreateFlightLoop_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XPLMCreateFlightLoop_t>(),
        24usize,
        concat!("Size of: ", stringify!(XPLMCreateFlightLoop_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XPLMCreateFlightLoop_t>(),
        8usize,
        concat!("Alignment of ", stringify!(XPLMCreateFlightLoop_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateFlightLoop_t),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateFlightLoop_t),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateFlightLoop_t),
            "::",
            stringify!(callbackFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refcon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPLMCreateFlightLoop_t),
            "::",
            stringify!(refcon)
        )
    );
}
extern "C" {
    #[doc = " XPLMGetElapsedTime"]
    #[doc = ""]
    #[doc = " This routine returns the elapsed time since the sim started up in decimal"]
    #[doc = " seconds. This is a wall timer; it keeps counting upward even if the sim is"]
    #[doc = " pasued."]
    #[doc = ""]
    #[doc = " __WARNING__: XPLMGetElapsedTime is not a very good timer!  It lacks"]
    #[doc = " precision in both its data type and its source.  Do not attempt to use it"]
    #[doc = " for timing critical applications like network multiplayer."]
    #[doc = ""]
    pub fn XPLMGetElapsedTime() -> f32;
}
extern "C" {
    #[doc = " XPLMGetCycleNumber"]
    #[doc = ""]
    #[doc = " This routine returns a counter starting at zero for each sim cycle"]
    #[doc = " computed/video frame rendered."]
    #[doc = ""]
    pub fn XPLMGetCycleNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XPLMRegisterFlightLoopCallback"]
    #[doc = ""]
    #[doc = " This routine registers your flight loop callback. Pass in a pointer to a"]
    #[doc = " flight loop function and a refcon. inInterval defines when you will be"]
    #[doc = " called. Pass in a positive number to specify seconds from registration time"]
    #[doc = " to the next callback. Pass in a negative number to indicate when you will"]
    #[doc = " be called (e.g. pass -1 to be called at the next cylcle). Pass 0 to not be"]
    #[doc = " called; your callback will be inactive."]
    #[doc = ""]
    #[doc = " (This legacy function only installs pre-flight-loop callbacks; use"]
    #[doc = " XPLMCreateFlightLoop for more control.)"]
    #[doc = ""]
    pub fn XPLMRegisterFlightLoopCallback(
        inFlightLoop: XPLMFlightLoop_f,
        inInterval: f32,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMUnregisterFlightLoopCallback"]
    #[doc = ""]
    #[doc = " This routine unregisters your flight loop callback. Do NOT call it from"]
    #[doc = " your flight loop callback. Once your flight loop callback is unregistered,"]
    #[doc = " it will not be called again."]
    #[doc = ""]
    #[doc = " Only use this on flight loops registered via"]
    #[doc = " XPLMRegisterFlightLoopCallback."]
    #[doc = ""]
    pub fn XPLMUnregisterFlightLoopCallback(
        inFlightLoop: XPLMFlightLoop_f,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMSetFlightLoopCallbackInterval"]
    #[doc = ""]
    #[doc = " This routine sets when a callback will be called. Do NOT call it from your"]
    #[doc = " callback; use the return value of the callback to change your callback"]
    #[doc = " interval from inside your callback."]
    #[doc = ""]
    #[doc = " inInterval is formatted the same way as in XPLMRegisterFlightLoopCallback;"]
    #[doc = " positive for seconds, negative for cycles, and 0 for deactivating the"]
    #[doc = " callback. If inRelativeToNow is 1, times are from the time of this call;"]
    #[doc = " otherwise they are from the time the callback was last called (or the time"]
    #[doc = " it was registered if it has never been called."]
    #[doc = ""]
    pub fn XPLMSetFlightLoopCallbackInterval(
        inFlightLoop: XPLMFlightLoop_f,
        inInterval: f32,
        inRelativeToNow: ::std::os::raw::c_int,
        inRefcon: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " XPLMCreateFlightLoop"]
    #[doc = ""]
    #[doc = " This routine creates a flight loop callback and returns its ID. The flight"]
    #[doc = " loop callback is created using the input param struct, and is inited to be"]
    #[doc = " unscheduled."]
    #[doc = ""]
    pub fn XPLMCreateFlightLoop(inParams: *mut XPLMCreateFlightLoop_t) -> XPLMFlightLoopID;
}
extern "C" {
    #[doc = " XPLMDestroyFlightLoop"]
    #[doc = ""]
    #[doc = " This routine destroys a flight loop callback by ID. Only call it on flight"]
    #[doc = " loops created with the newer XPLMCreateFlightLoop API."]
    #[doc = ""]
    pub fn XPLMDestroyFlightLoop(inFlightLoopID: XPLMFlightLoopID);
}
extern "C" {
    #[doc = " XPLMScheduleFlightLoop"]
    #[doc = ""]
    #[doc = " This routine schedules a flight loop callback for future execution. If"]
    #[doc = " inInterval is negative, it is run in a certain number of frames based on"]
    #[doc = " the absolute value of the input. If the interval is positive, it is a"]
    #[doc = " duration in seconds."]
    #[doc = ""]
    #[doc = " If inRelativeToNow is true, ties are interpretted relative to the time this"]
    #[doc = " routine is called; otherwise they are relative to the last call time or the"]
    #[doc = " time the flight loop was registered (if never called)."]
    #[doc = ""]
    pub fn XPLMScheduleFlightLoop(
        inFlightLoopID: XPLMFlightLoopID,
        inInterval: f32,
        inRelativeToNow: ::std::os::raw::c_int,
    );
}
